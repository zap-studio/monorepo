---
title: Best Practices
description: Learn the recommended practices for organizing your Zap.ts project, from file structure to performance optimization.
---

# Best Practices

Zap.ts is built to help you create apps _quickly_ with a _**clear**_ and _**organized**_ structure.

This page explains the recommended way to set up your project and why it works well for building modern apps.

## Project Structure

The `src` folder in Zap.ts is organized to keep your code _clean_, _easy to find_, and _ready to grow_ (see [getting started](/docs/introduction/getting-started)). Here's what each folder does:

As a best practice, you should follow these conventions when organizing your code:

- **actions**: Holds server actions for handling backend tasks.
- **app**: Contains Next.js app router files, such as pages and layouts.
- **components**: Stores reusable UI components.
  - **common**: General components used across the app.
  - **ui**: Components styled with [shadcn/ui](https://ui.shadcn.com/), focusing on design consistency.
- **data**: Keeps static data, like JSON files, and feature flags to turn features on or off at build time without a database.
- **db**: Includes database-related code, such as schemas.
- **hooks**: Holds custom React hooks that can be shared across features.
- **lib**: Stores shared utilities, like helper functions or API clients.
- **providers**: Contains React context providers for app-wide state.
- **rpc**: Manages code for type-safe API communication.
- **schemas**: Defines schemas and API validation schemas for type safety.
- **services**: Encapsulates your business logic and domain operations
- **stores**: Holds stores for lightweight state management.
- **styles**: Includes global styles.

## Pages vs. Routes

Inside the `app` folder, you'll find some special folders that help you organize your code. These **do not affect your route structure** — they just make things easier to manage:

- **public** – For public-facing pages and APIs (no auth required)
  > Example: `/(public)/index.tsx`

- **protected** – For protected routes (auth required)
  > Example: `/api/(protected)/user/update-account/route.ts`

These folders let you group your logic by access level without affecting the final URL structure.

<Callout type="info" title="Understanding Routes">
In Next.js, routes come in _two main types_:

* **API**: A backend endpoint for handling HTTP requests. Used for data fetching, mutations, etc.
* **Page**: A UI screen rendered by a React component. These can be public or protected, static or dynamic.

Learn more in the [Next.js documentation](https://nextjs.org/docs/app/getting-started/project-structure#routing-files).
</Callout>

## Server Actions vs. API Routes

**Server Actions** and **API Routes** both handle _backend_ logic, but they work differently:

- **Server Actions**: Server-side functions for tasks like form submissions. They run on the server and are good for one-off operations. They don't need a separate endpoint.
- **API Routes**: Next.js endpoints (e.g., `/api/users`) for reusable APIs. They're better for parallel requests and external access. With oRPC, they become type-safe.

It's important to note that **API Routes** handle concurrent requests, making them ideal for data fetching and external APIs, while **Server Actions** run sequentially and are better suited for isolated _mutation_ tasks.

<Callout type="warn">
In general, we advise against using **Server Actions**. They are essentially another way to define **API Routes**, but with less control and flexibility.
</Callout>

## Providers vs. Zustand Stores

The `providers` folder is for React context providers, but we recommend using Zustand stores for state management whenever possible.

**React Context** is great for static or infrequently changing values (like themes or locales), but it can lead to unnecessary re-renders when used for dynamic state.

```tsx
import React, { createContext, useState, useContext, ReactNode } from "react";

type Theme = "light" | "dark";

interface ThemeContextType {
  theme: Theme;
  setTheme: (theme: Theme) => void;
  toggleTheme: () => void;
}

const ThemeContext = createContext<ThemeContextType | undefined>(undefined);

export function ThemeProvider({ children }: { children: ReactNode }) {
  const [theme, setTheme] = useState<Theme>("light");

  const toggleTheme = () => {
    setTheme((prev) => (prev === "light" ? "dark" : "light"));
  };

  return (
    <ThemeContext.Provider value={{ theme, setTheme, toggleTheme }}>
      {children}
    </ThemeContext.Provider>
  );
}

export function useTheme() {
  const context = useContext(ThemeContext);
  if (!context) {
    throw new Error("useTheme must be used within a ThemeProvider");
  }
  return context;
}
```

**Zustand**, on the other hand, is a lightweight state manager that avoids this problem by isolating updates and keeping your components more performant.

```ts
import { create } from "zustand";

export const useCartStore = create(set => ({
  items: [],
  addItem: item => set(state => ({ items: [...state.items, item] })),
}));
```

We recommend you to check [Zustand documentation](https://zustand.docs.pmnd.rs/getting-started/introduction) to learn more.

<Callout type="info">
Use `providers` only when you have no other choice (e.g., for third-party libraries requiring context). For app state, use Zustand stores in the `stores` folder—they're lighter and easier to manage.
</Callout>



## URL State Management

For state that should be **shareable via URL** (like filters, search terms, or pagination), use [nuqs](https://nuqs.vercel.app/) — a powerful library that makes URL state management as simple as `useState`.

**nuqs** provides hooks that automatically sync your component state with URL search parameters, enabling:

- **Shareable URLs** — Users can bookmark or share filtered views
- **Browser navigation** — Back/forward buttons work naturally with your app state
- **Deep linking** — Direct links to specific app states
- **SEO-friendly URLs** — Search engines can index different states of your app

**nuqs** makes it easy to implement these features with minimal boilerplate. See the below example.

```tsx
"use client";

import { parseAsInteger, useQueryState } from "nuqs";

export function Demo() {
  const [hello, setHello] = useQueryState("hello", { defaultValue: "" });
  const [count, setCount] = useQueryState(
    "count",
    parseAsInteger.withDefault(0),
  );

  return (
    <>
      <button onClick={() => setCount((c) => c + 1)}>Count: {count}</button>
      <input
        value={hello}
        placeholder="Enter your name"
        onChange={(e) => setHello(e.target.value || null)}
      />
      <p>Hello, {hello || "anonymous visitor"}!</p>
    </>
  );
}
```

## Type-Safe APIs

The `schemas` folder uses **Zod** to define validation schemas for your database and API requests.

These schemas ensure your data always matches the expected shape, reducing bugs and runtime errors.

```ts
// src/schemas/product.schema.ts
import { z } from "zod";

export const ProductSchema = z.object({
  id: z.string(),
  name: z.string(),
  price: z.number(),
});
```

With **oRPC**, you leverage these schemas to enforce **end-to-end type safety**—from frontend to backend—so your types are automatically inferred and consistent across your entire app.

```ts
// src/rpc/procedures/product.rpc.ts
import { os } from "@orpc/server";
import { z } from "zod";

const ProductSchema = z.object({
  id: z.string(),
  name: z.string(),
  price: z.number(),
});

export const getProduct = os
  .input(ProductSchema.pick({ id: true }))
  .output(ProductSchema)
  .handler(async ({ input }) => {
    // ...fetch product from database or service
    return { id: input.id, name: "Sample", price: 10 };
  })
  .callable();
```

Moreover, we consider **TypeScript mandatory** because it catches errors early, improves developer productivity, and makes your codebase more maintainable and scalable as it grows.

Contrary to common belief, focusing on type safety and strong typing actually helps you build _**faster**_ and with _**more confidence**_—by preventing subtle bugs and costly refactors down the line, not to mention enabling **powerful IntelliSense** that speeds up development.


## Arrow Functions vs. Named Functions

Understanding when to use arrow functions versus named functions is crucial for writing clean, maintainable code.

Each has specific use cases where they excel:

### Arrow Functions

- **Event handlers and callbacks** — They automatically bind `this` and are more concise
  ```tsx
  const handleClick = () => {
    setCount(prev => prev + 1)
  }
  ```

- **Simple utility functions** — When the function is short and focused
  ```tsx
  const formatCurrency = (amount: number) => `$${amount.toFixed(2)}`
  ```

- **Array methods** — For map, filter, reduce operations
  ```tsx
  const doubled = numbers.map(n => n * 2)
  ```

### Named Functions

- **Complex logic** — When the function has multiple responsibilities or is longer
  ```tsx
  function validateUserInput(input: UserInput): ValidationResult {
    const errors = []
    
    if (!input.email) {
      errors.push('Email is required')
    }
    
    if (input.password.length < 8) {
      errors.push('Password must be at least 8 characters')
    }
    
    return { isValid: errors.length === 0, errors }
  }
  ```

- **Recursive functions** — Named functions can reference themselves
  ```tsx
  function factorial(n: number): number {
    return n <= 1 ? 1 : n * factorial(n - 1)
  }
  ```

- **Functions that need hoisting** — When you need to call the function before it's defined
  ```tsx
  function processData() {
    return transformData(validateData())
  }
  
  function validateData() { /* ... */ }
  function transformData() { /* ... */ }
  ```

- **Class methods** — For object-oriented patterns
  ```tsx
  class UserService {
    async getUser(id: string) {
      return await this.api.get(`/users/${id}`)
    }
  }
  ```

### Explanations

**Hoisting** is a JavaScript mechanism where function and variable declarations are moved to the top of their scope during the compilation phase.

**Named function** declarations are _fully hoisted_, meaning you can call them before they're defined in your code.

```ts
// Named function (hoisted)
console.log(square(5)); // 25
function square(x) {
  return x * x;
}

// Arrow function (not hoisted)
// console.log(double(5)); // ReferenceError: Cannot access 'double' before initialization
const double = (x) => x * 2;
```

However, arrow functions are not hoisted because they're assigned to variables using `const` or `let`, which follow the temporal dead zone rule.

Additionally, **React DevTools** displays component names more clearly when using named functions.

```tsx
// Named function component (shows as 'UserCard' in DevTools)
function UserCard({ user }) {
  return <div>{user.name}</div>;
}

// Arrow function component (shows as 'Anonymous' or less descriptive)
const UserCard = ({ user }) => {
  return <div>{user.name}</div>;
};
```

Indeed, arrow functions assigned to variables often show up as "Anonymous" or with less descriptive names in the component tree, making debugging more difficult.

Thus, named functions offer superior debugging capabilities and component identification in React DevTools compared to anonymous arrow functions.

## Performance & Optimization

Performance directly impacts user experience and SEO. Here are the key Next.js _optimization strategies_ to understand:

- **Bundle Analysis**  
  Regularly analyze your bundles with tools like [`@next/bundle-analyzer`](https://www.npmjs.com/package/@next/bundle-analyzer) to find and reduce large dependencies or unnecessary code.

- **Lazy Loading (Dynamic Import)**  
  Use [dynamic imports](https://nextjs.org/docs/app/guides/lazy-loading) (`dynamic()`) to load heavy or rarely used components on demand, reducing the initial bundle size and speeding up page loads. 

    ```tsx
    // Lazy load a heavy component
    import dynamic from "next/dynamic";
    const HeavyComponent = dynamic(() => import("@/components/HeavyComponent"), {
      loading: () => <p>Loading...</p>,
      ssr: false,
    });

    export default function Page() {
      return <HeavyComponent />;
    }
    ```

- **Route Prefetching**  
  Take advantage of Next.js's automatic [link prefetching](https://nextjs.org/docs/app/api-reference/components/link#prefetch) (`<Link prefetch>`) to preload pages users are likely to visit next, enabling faster navigation.

    ```tsx
    import Link from "next/link";

    export default function Nav() {
      return (
        <nav>
          <Link href="/about" prefetch={true}>About</Link>
          <Link href="/blog" prefetch={true}>Blog</Link>
        </nav>
      );
    }
    ```

- **SSR vs SSG vs ISR**  
  - *SSR ([Server-Side Rendering](https://nextjs.org/docs/app/guides/migrating/app-router-migration#server-side-rendering-getserversideprops))*: Best for dynamic pages that need fresh data on every request such as user dashboards.  
  - *SSG ([Static Site Generation](https://nextjs.org/docs/app/guides/migrating/app-router-migration#static-site-generation-getstaticprops))*: Ideal for mostly static pages that rarely change like marketing pages.  
  - *ISR ([_Incremental Static Generation_](https://nextjs.org/docs/app/guides/incremental-static-regeneration))*: A hybrid approach for mostly static pages with occasional updates, like blogs with frequent content changes. 

    ```tsx
    // SSR: app/dashboard/page.tsx
    export default async function Page() {
      const res = await fetch("https://api.example.com/user", { cache: "no-store" });
      const user = await res.json();
      return <div>{user.name}</div>;
    }

    // SSG: app/posts/[id]/page.tsx
    export async function generateStaticParams() {
      const res = await fetch("https://api.example.com/posts");
      const posts = await res.json();
      return posts.map((post) => ({ id: post.id }));
    }

    export default async function Page({ params }) {
      const res = await fetch(`https://api.example.com/posts/${params.id}`);
      const post = await res.json();
      return <article><h1>{post.title}</h1><p>{post.body}</p></article>;
    }

    // ISR: app/blog/page.tsx
    export const revalidate = 60; // seconds
    export default async function Page() {
      const res = await fetch("https://api.example.com/blog");
      const blog = await res.json();
      return <div>{blog.title}</div>;
    }
    ```

## Middleware

Next.js **Middleware** lets you intercept HTTP requests before they reach your pages or APIs, use it to:

- Handle authentication and conditional redirects  
- Modify HTTP headers for security (CSP, CORS)  
- Implement dynamic routing or localization

It leverages the **Edge Runtime** that runs your code at the network edge, _closest to users_, providing _ultra-low latency_ and _instant scalability_.

## Naming Files

Follow these naming rules for clarity:

- **Components:** Use `component-name.tsx`  
  > Example: `user-card.tsx`

- **Constants (in the `data` folder):** Use uppercase naming  
  > Examples: `FLAGS`, `BASE_URL`

- **Database Schema:** Use `your-schema.sql.ts`  
  > Example: `auth.sql.ts`

- **Hooks:** Use `use-hook.ts`  
  > Example: `use-user-profile.ts`

- **Mails:** Use `your-mail.mail.ts`
  > Example: `template.mail.tsx`

- **Queries:** Use `your-query.query.ts`  
  > Example: `get-users.query.ts`

- **RPC Procedures:** Use `your-procedure.rpc.ts`  
  > Example: `user.rpc.ts`

- **Server Actions:** Use `your-action.action.ts`  
  > Example: `update-user.action.ts`

- **Services:** Use `your-service.service.ts`  
  > Example: `update-user.service.ts`

- **Stores:** Use `your-store.store.ts`  
  > Example: `user.store.ts`

- **Zod Schemas:** Use `your-schema.schema.ts` and prefer PascalCase for schema names  
  > Example file: `user.schema.ts`  
  > Example schema name: `UserSchema` (not `userSchema`)

- **Other files:** Follow React naming conventions, like PascalCase for components.

## Maximize Your IDE Efficiency

It may sound _cliché_, but using your IDE's search and navigation features can save you a lot of time when jumping between files.

<Callout type="info" title="VSCode Navigation">
In VSCode, hold `CMD` (or `Ctrl` on Windows) and left-click a file name (e.g., `use-user-profile.ts`) to open it quickly.
</Callout>

## Rationale

These best practices are designed with *scalability*, *maintainability*, and *developer experience* in mind:

* **Clear separation of concerns** keeps your code modular, making it easier to navigate and update without breaking unrelated parts.
* Using **type-safe APIs** drastically reduces runtime errors and boosts confidence by catching bugs early during development.
* Favoring **Zustand over React context** for app state prevents unnecessary re-renders and improves performance.
* Emphasizing **TypeScript as mandatory** ensures consistent code quality, better refactoring, and superior tooling support (like IntelliSense).
* Leveraging **Next.js's file-system routing** alongside logical folder grouping makes your app structure intuitive without complicating URLs.
* Encouraging **IDE efficiency** habits minimizes friction in your workflow, allowing you to focus more on building features than on hunting down files.

In short, this approach balances *speed*, *robustness*, and *clarity* to help you build modern apps that last.
