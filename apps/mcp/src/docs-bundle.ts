// This file is auto-generated , please don't edit it .
export const allDocs = {
  "introduction.md": "# What is Zap Studio?\n\nWe're building the infrastructure layer for modern web development. Zap Studio provides open-source tools and primitives that help developers ship production-ready applications in days, not months.\n\n## The Problem\n\nEvery developer starting a new project faces the same challenges: setting up authentication, configuring databases, handling payments, managing emails. This boilerplate work costs teams weeks of development time and introduces countless opportunities for security vulnerabilities.\n\n## Our Solution\n\nWe're solving this by building a suite of modular, production-ready tools that just work:\n\n### Zap.ts\n\nOur flagship product is [Zap.ts](https://zapstudio.dev/zap-ts) ‚Äî the fastest way to go from idea to production. It's a modular starter kit that includes everything you need to build and scale a web application.\n\n**What's included:**\n-  Authentication with Better Auth\n-  Database with Drizzle ORM\n-  UI with Tailwind CSS + shadcn/ui\n-  Payments with Polar\n-  Deploy anywhere\n\n### Local.ts\n\n[Local.ts](./local-ts/) is our starter kit for building local-first desktop applications. Your data stays on the device, always available offline, with native performance.\n\n**What's included:**\n- Cross-platform desktop apps with Tauri\n- SQLite database with Diesel ORM\n- Settings, theming, and notifications\n- System tray, autostart, and window state\n- React + TypeScript frontend\n\n### Developer Infrastructure\n\nWe're also building a suite of packages that solve common problems with modern, composable APIs.\n\n**Our engineering principles:**\n\n- **ESM First** ‚Äî Native ES modules for modern JavaScript. No legacy baggage.\n- **100% Type Safe** ‚Äî Full TypeScript with strict types. Catch bugs before they ship.\n- **Modular Architecture** ‚Äî Core + adapter pattern. Use only what you need.\n- **Tree Shakeable** ‚Äî Zero bloat. Your bundle stays lean.\n\n| Package | Description | Status |\n|---------|-------------|--------|\n| [@zap-studio/fetch](./packages/fetch/index.md) | Type-safe fetch wrapper with validation | ‚úÖ Available |\n| [@zap-studio/permit](./packages/permit/index.md) | Type-safe authorization and access control | ‚úÖ Available |\n| [@zap-studio/validation](./packages/validation/index.md) | Shared Standard Schema utilities and validation helpers | ‚úÖ Available |\n| @zap-studio/realtime | Realtime events with SSE and WebSocket support | üöß Coming Soon |\n| @zap-studio/waitlist | Waitlist management solution | üöß Coming Soon |\n| @zap-studio/webhooks | Webhook handling with signature verification | üöß Coming Soon |\n\n## Why Now?\n\nThe JavaScript ecosystem has matured. TypeScript is the standard. ESM is native. Edge runtimes are everywhere. The tools developers use should reflect this new reality ‚Äî not carry the weight of a decade of backwards compatibility.\n\nWe're building the next generation of developer tools from the ground up.\n",
  "index.md": "---\n# https://vitepress.dev/reference/default-theme-home-page\nlayout: home\n\nhero:\n  name: \"Zap Studio ‚ö°Ô∏è\"\n  tagline: \"Building open-source projects to help developers ship faster with confidence.\"\n  # image:\n    # light: /code-light.png\n    # dark: /code-dark.png\n    # alt: Zap Studio Code Snippet\n  actions:\n    - theme: brand\n      text: Introduction\n      link: /introduction\n    - theme: alt\n      text: About\n      link: /about\n\nfeatures:\n  - title: Zap.ts\n    icon: \"‚ö°Ô∏è\"\n    details: A production-grade monorepo starter kit to ship quickly and securely.\n    link: ./zap-ts\n\n  - title: Local.ts\n    icon: \"üíæ\"\n    details: A starter kit for building local-first desktop applications with Tauri and React.\n    link: ./local-ts\n\n  - title: \"@zap-studio/fetch\"\n    icon: \"üì°\"\n    details: A lightweight, type-safe fetch wrapper with built-in validation and error handling.\n    link: ./packages/fetch\n\n  - title: \"@zap-studio/permit\"\n    icon: \"üîê\"\n    details: A type-safe, declarative authorization library with Standard Schema support.\n    link: ./packages/permit\n\n  - title: \"@zap-studio/validation\"\n    icon: \"‚úÖ\"\n    details: Shared Standard Schema utilities and ValidationError helpers.\n    link: ./packages/validation\n\n  - title: \"@zap-studio/realtime\"\n    icon: \"üì°\"\n    details: Realtime events with SSE and WebSocket support. Coming soon.\n    link: ./packages/realtime\n\n  - title: \"@zap-studio/waitlist\"\n    icon: \"‚è≥\"\n    details: A simple waitlist management solution for your applications.\n    link: ./packages/waitlist\n\n  - title: \"@zap-studio/webhooks\"\n    icon: \"ü™ù\"\n    details: A robust webhook handling library with signature verification.\n    link: ./packages/webhooks\n\n---\n",
  "about.md": "# About\n\n## Our Mission\n\n**We're on a mission to make developers 10x more productive.**\n\nMillions of hours are wasted every year rebuilding the same infrastructure: auth, payments, emails, APIs. We're fixing that by creating the building blocks that let developers focus on what makes their product unique.\n\n## What We Believe\n\n- **Speed is a feature.** The faster you can ship, the faster you can learn.\n- **Open source wins.** Transparency builds trust. Community drives innovation.\n- **Developer experience matters.** Great tools should feel invisible.\n- **Quality over quantity.** We'd rather ship one excellent tool than ten mediocre ones.\n\n## What We're Building\n\n### Zap.ts ‚Äî Ship in Days, Not Months\n\n[Zap.ts](./zap-ts/index.md) is our flagship product: a production-ready Next.js starter that handles all the boring stuff so you can focus on your product.\n\nTeams using Zap.ts go from zero to deployed in under an hour.\n\n### Local.ts ‚Äî Local-First Desktop Apps\n\n[Local.ts](./local-ts/index.md) is our starter kit for building cross-platform desktop applications with a local-first architecture. Built with Tauri, React, and Rust.\n\nYour data stays on the device, always available offline, with native performance and a small bundle size.\n\n### @zap-studio Packages ‚Äî Modern Primitives\n\nWe're building a suite of composable packages under the `@zap-studio` scope:\n\n| Package | What it does |\n|---------|-------------|\n| [@zap-studio/fetch](./packages/fetch/index.md) | Type-safe HTTP client with runtime validation |\n| [@zap-studio/permit](./packages/permit/index.md) | Type-safe centralized & secure authorization with zero config |\n| [@zap-studio/validation](./packages/validation/index.md) | Shared Standard Schema utilities and validation helpers |\n| @zap-studio/realtime | Realtime events with SSE and WebSocket support |\n| @zap-studio/waitlist | Launch waitlists in minutes |\n| @zap-studio/webhooks | Secure webhook handling with zero config |\n\n## Our Approach\n\nWe build in public. Everything we ship is open source under permissive licenses. We believe the best developer tools are built by developers who use them every day.\n\n## Get Involved\n\nWe're just getting started. Star us on [GitHub](https://github.com/zap-studio), try our tools, and let us know what you think.\n",
  "zap-ts/index.md": "# Zap.ts\n\n::: warning Coming Soon\nZap.ts documentation is currently under development. Stay tuned for updates!\n:::\n\n## What is Zap.ts?\n\nZap.ts is a modern, full-stack TypeScript monorepo starter kit designed to help you build fast with ease. It comes with everything you need to launch your next project.\n\n## Features\n\n- **Authentication** - Complete auth system with multiple providers using Better Auth\n- **Email** - Transactional emails with React Email templates and Resend\n- **Payments** - Polar integration for subscriptions and billing\n- **Database** - Type-safe database access with Drizzle ORM\n- **UI Components** - Pre-built components with shadcn/ui\n- **Analytics** - User tracking with PostHog\n- **Internationalization** - Built-in i18n support\n- **Deployment** - Deploy anywhere with Vercel or Docker\n\n## Stay Updated\n\nJoin our [Discord community](https://discord.gg/8Ke3VCjjMf) to stay updated on the latest developments and be the first to know when Zap.ts is ready for public release.\n\nFollow us on [GitHub](https://github.com/zap-studio) for updates and to star the project!\n",
  "packages/webhooks/index.md": "# @zap-studio/webhooks\n\n::: warning Coming Soon\nThe documentation for `@zap-studio/webhooks` is currently under development. Stay tuned for updates!\n:::\n\n## What is @zap-studio/webhooks?\n\n`@zap-studio/webhooks` is a type-safe webhook handling library for TypeScript applications. It provides a simple and secure way to receive, validate, and process webhooks from various services.\n\n## Features (Preview)\n\n- **Secure Signature Verification** - Built-in signature validation for popular providers\n- **Type-Safe Event Handling** - Full TypeScript support with type inference\n- **Framework Agnostic** - Works with any Node.js framework\n- **Extensible** - Easy to add custom webhook providers\n\n## Installation\n\n```bash\npnpm add @zap-studio/webhooks\n# or\nnpm install @zap-studio/webhooks\n```\n\n## Stay Updated\n\nJoin our [Discord community](https://discord.gg/8Ke3VCjjMf) to stay updated on the latest developments.\n",
  "packages/waitlist/index.md": "# @zap-studio/waitlist\n\n::: warning Coming Soon\nThe documentation for `@zap-studio/waitlist` is currently under development. Stay tuned for updates!\n:::\n\n## What is @zap-studio/waitlist?\n\n`@zap-studio/waitlist` is a complete waitlist management solution for TypeScript applications. It provides everything you need to implement a waitlist system with referrals, analytics, and more.\n\n## Features (Preview)\n\n- **Easy Integration** - Simple API for adding users to your waitlist\n- **Referral System** - Built-in referral tracking and rewards\n- **Analytics** - Track waitlist growth and engagement\n- **Customizable** - Flexible configuration to match your needs\n\n## Installation\n\n```bash\npnpm add @zap-studio/waitlist\n# or\nnpm install @zap-studio/waitlist\n```\n\n## Stay Updated\n\nJoin our [Discord community](https://discord.gg/8Ke3VCjjMf) to stay updated on the latest developments.\n",
  "packages/validation/index.md": "# @zap-studio/validation\n\nStandard Schema utilities and `ValidationError` helpers.\n\n## Why @zap-studio/validation?\n\nWhen working with Standard Schema-compatible libraries (Zod, Valibot, ArkType, etc.), you often want:\n\n- A **single error type** to represent validation failures.\n- A **simple way to detect** whether a value is a Standard Schema.\n- A **consistent helper** for validating data in both throwing and non-throwing modes.\n\n`@zap-studio/validation` provides exactly that, and is used internally by `@zap-studio/fetch` and other Zap Studio runtime packages.\n\n## Installation\n\n```bash\npnpm add @zap-studio/validation\n# or\nnpm install @zap-studio/validation\n```\n\n## Core Concepts\n\n### ValidationError\n\n`ValidationError` is a shared error type thrown when Standard Schema validation fails.\n\n```ts\nimport { ValidationError } from \"@zap-studio/validation/errors\";\n\ntry {\n  const value = await standardValidate(schema, data, true);\n  console.log(\"Validated:\", value);\n} catch (error) {\n  if (error instanceof ValidationError) {\n    console.error(\"Validation failed:\", error.issues);\n  }\n}\n```\n\n### isStandardSchema\n\n`isStandardSchema` is a type guard that tells you whether a value is a Standard Schema-compatible schema.\n\n```ts\nimport { isStandardSchema } from \"@zap-studio/validation\";\n\nif (isStandardSchema(schema)) {\n  // TypeScript now knows `schema` is a StandardSchemaV1\n  const result = await standardValidate(schema, data, true);\n}\n```\n\n### standardValidate\n\n`standardValidate` normalizes sync and async Standard Schema validation, and supports both throwing and non-throwing flows.\n\n```ts\nimport { standardValidate } from \"@zap-studio/validation\";\n\n// Synchronous or asynchronous schema ‚Äì handled transparently\nconst value = await standardValidate(schema, data, true);\n\n// Non-throwing mode (sync or async schema)\nconst result = await standardValidate(schema, data, false);\nif (result.issues) {\n  console.error(\"Validation failed:\", result.issues);\n} else {\n  console.log(\"Validation passed:\", result.value);\n}\n```\n\n### createSyncStandardValidator\n\n`createSyncStandardValidator` builds a synchronous validator function from a Standard Schema schema. It calls `schema[\"~standard\"].validate` and throws if the schema performs async validation (returns a Promise).\n\n```ts\nimport { createSyncStandardValidator } from \"@zap-studio/validation\";\n\n// Build a sync-only validator for a Standard Schema-compatible schema\nconst validateUser = createSyncStandardValidator(UserSchema);\n\nconst result = validateUser(data);\nif (result.issues) {\n  console.error(\"Validation failed:\", result.issues);\n} else {\n  console.log(\"Validation passed:\", result.value);\n}\n```\n\n\n",
  "packages/realtime/index.md": "# @zap-studio/realtime\n\n:::: warning Coming Soon\nThe documentation for `@zap-studio/realtime` is currently under development. Stay tuned for updates!\n::::\n\n## What is @zap-studio/realtime?\n\n`@zap-studio/realtime` will provide realtime event delivery with Server-Sent Events (SSE) and WebSocket support to keep your applications responsive and up to date.\n\n## Status\n\n- Realtime package is in progress ‚Äî more details soon.\n\n## Stay Updated\n\nJoin our [Discord community](https://discord.gg/8Ke3VCjjMf) to stay updated on the latest developments.\n\n\n",
  "packages/permit/roles.md": "# Role-Based Access Control\n\nRole-Based Access Control (RBAC) is a common authorization pattern where permissions are assigned to roles, and users are assigned roles. `@zap-studio/permit` provides utilities for implementing RBAC with support for role hierarchies.\n\n## Understanding RBAC\n\nIn RBAC, instead of assigning permissions directly to users, you:\n\n1. Define **roles** (e.g., \"guest\", \"user\", \"admin\")\n2. Assign **permissions** to roles (e.g., admin can delete posts)\n3. Assign **roles** to users (e.g., Alice is an admin)\n\nThis simplifies permission management‚Äîwhen you need to change what admins can do, you update the role's permissions once instead of updating every admin user.\n\n## Simple Role Checks\n\nThe `hasRole()` function checks if the current user has a specific role:\n\n```typescript\nimport { hasRole } from \"@zap-studio/permit\";\n\nhasRole(role)\n```\n\n### Context Requirements\n\nYour context must include a `role` property that can be:\n- A single role: `{ role: \"admin\" }`\n- An array of roles: `{ role: [\"user\", \"moderator\"] }`\n\n### Example: Basic RBAC\n\n```typescript\nimport { z } from \"zod\";\nimport { createPolicy, when, hasRole, or } from \"@zap-studio/permit\";\nimport type { Resources, Actions } from \"@zap-studio/permit/types\";\n\nconst resources = {\n  post: z.object({\n    id: z.string(),\n    authorId: z.string(),\n    status: z.enum([\"draft\", \"published\", \"archived\"]),\n  }),\n  user: z.object({\n    id: z.string(),\n    email: z.string(),\n  }),\n} satisfies Resources;\n\nconst actions = {\n  post: [\"read\", \"write\", \"delete\", \"publish\"],\n  user: [\"read\", \"update\", \"delete\", \"ban\"],\n} as const satisfies Actions<typeof resources>;\n\ntype Role = \"guest\" | \"user\" | \"moderator\" | \"admin\";\n\ntype AppContext = {\n  user: { id: string } | null;\n  role: Role;\n};\n\nconst policy = createPolicy<AppContext>({\n  resources,\n  actions,\n  rules: {\n    post: {\n      // Guests can read published posts\n      read: when((ctx, _, post) =>\n        post.status === \"published\" || ctx.role === \"user\"\n      ),\n      // Users can write their own posts\n      write: when((ctx, _, post) =>\n        ctx.role === \"user\" && ctx.user?.id === post.authorId\n      ),\n      // Moderators and admins can delete any post\n      delete: when(\n        or(\n          hasRole(\"moderator\"),\n          hasRole(\"admin\")\n        )\n      ),\n      // Only admins can publish\n      publish: when(hasRole(\"admin\")),\n    },\n    user: {\n      // Users can read their own profile, admins can read any\n      read: when(\n        or(\n          (ctx, _, user) => ctx.user?.id === user.id,\n          hasRole(\"admin\")\n        )\n      ),\n      // Users can update their own profile\n      update: when((ctx, _, user) => ctx.user?.id === user.id),\n      // Only admins can delete users\n      delete: when(hasRole(\"admin\")),\n      // Moderators and admins can ban users\n      ban: when(\n        or(\n          hasRole(\"moderator\"),\n          hasRole(\"admin\")\n        )\n      ),\n    },\n  },\n});\n```\n\n::: warning\nFor now, `hasRole()` returns a `ConditionFn`, which can be used in `when()` conditions. Thus, it doesn't return a boolean value directly. Prefer using `role` directly in conditions.\n:::\n\n## Role Hierarchies\n\nOften, higher-level roles inherit permissions from lower-level roles. For example, an admin should have all permissions that a user has, plus admin-specific ones.\n\n### Defining a Role Hierarchy\n\nA role hierarchy maps each role to an array of roles it inherits from:\n\n```typescript\nimport type { RoleHierarchy } from \"@zap-studio/permit/types\";\n\ntype Role = \"guest\" | \"user\" | \"moderator\" | \"admin\";\n\nconst roleHierarchy: RoleHierarchy<Role> = {\n  guest: [],                    // No inherited roles\n  user: [\"guest\"],              // Users inherit guest permissions\n  moderator: [\"user\"],          // Moderators inherit user permissions\n  admin: [\"moderator\"],         // Admins inherit moderator permissions\n};\n\n// Permission inheritance chain:\n// admin ‚Üí moderator ‚Üí user ‚Üí guest\n```\n\n### Using hasRole with Hierarchy\n\nPass the hierarchy as the second argument to `hasRole()`:\n\n```typescript\nimport { hasRole } from \"@zap-studio/permit\";\n\n// Without hierarchy: only matches exact role\nhasRole(\"user\")  // Only true if role === \"user\"\n\n// With hierarchy: matches role or any role that inherits from it\nhasRole(\"user\", roleHierarchy)  // True for \"user\", \"moderator\", or \"admin\"\n```\n\n## Multiple Roles\n\nUsers can have multiple roles. The context can include an array of roles:\n\n```typescript\ntype AppContext = {\n  user: { id: string } | null;\n  role: Role[];  // Array of roles\n};\n\nconst context: AppContext = {\n  user: { id: \"user-1\" },\n  role: [\"user\", \"beta-tester\"],  // User has both roles\n};\n```\n\n`hasRole()` checks if any of the user's roles match (or inherit from) the required role.\n\n### Example: Multiple Roles\n\n```typescript\nimport { z } from \"zod\";\nimport { createPolicy, when, hasRole, and, or } from \"@zap-studio/permit\";\nimport type { Resources, Actions, RoleHierarchy } from \"@zap-studio/permit/types\";\n\nconst resources = {\n  betaFeature: z.object({\n    id: z.string(),\n    name: z.string(),\n  }),\n  supportTicket: z.object({\n    id: z.string(),\n    userId: z.string(),\n    priority: z.enum([\"low\", \"normal\", \"high\", \"urgent\"]),\n  }),\n} satisfies Resources;\n\nconst actions = {\n  betaFeature: [\"access\"],\n  supportTicket: [\"create\", \"escalate\"],\n} as const satisfies Actions<typeof resources>;\n\ntype Role = \"user\" | \"beta-tester\" | \"premium\" | \"support-agent\" | \"admin\";\n\nconst roleHierarchy: RoleHierarchy<Role> = {\n  user: [],\n  \"beta-tester\": [\"user\"],\n  premium: [\"user\"],\n  \"support-agent\": [\"user\"],\n  admin: [\"premium\", \"support-agent\"],  // Admin inherits from multiple roles\n};\n\ntype MultiRoleContext = {\n  user: { id: string } | null;\n  role: Role[];\n};\n\nconst multiRolePolicy = createPolicy<MultiRoleContext>({\n  resources,\n  actions,\n  rules: {\n    betaFeature: {\n      // Only beta testers can access beta features\n      access: when(hasRole(\"beta-tester\", roleHierarchy)),\n    },\n    supportTicket: {\n      // Any authenticated user can create tickets\n      create: when(hasRole(\"user\", roleHierarchy)),\n\n      // Only premium users or support agents can escalate\n      escalate: when(\n        or(\n          hasRole(\"premium\", roleHierarchy),\n          hasRole(\"support-agent\", roleHierarchy)\n        )\n      ),\n    },\n  },\n});\n\n// User with multiple roles\nconst betaPremiumUser: MultiRoleContext = {\n  user: { id: \"u1\" },\n  role: [\"user\", \"beta-tester\", \"premium\"],\n};\n\nconst ticket = { id: \"t1\", userId: \"u1\", priority: \"normal\" as const };\nconst feature = { id: \"f1\", name: \"New Dashboard\" };\n\nconsole.log(multiRolePolicy.can(betaPremiumUser, \"access\", \"betaFeature\", feature)); // true (has beta-tester)\nconsole.log(multiRolePolicy.can(betaPremiumUser, \"escalate\", \"supportTicket\", ticket)); // true (has premium)\n```\n\n## Collecting Inherited Roles\n\nThe `collectInheritedRoles()` function returns all roles a user has, including inherited ones:\n\n```typescript\nimport { collectInheritedRoles } from \"@zap-studio/permit\";\n\ncollectInheritedRoles(roles, hierarchy)\n```\n\n### Example: Role Inspection\n\n```typescript\nimport { collectInheritedRoles } from \"@zap-studio/permit\";\nimport type { RoleHierarchy } from \"@zap-studio/permit/types\";\n\ntype Role = \"guest\" | \"user\" | \"moderator\" | \"admin\";\n\nconst hierarchy: RoleHierarchy<Role> = {\n  guest: [],\n  user: [\"guest\"],\n  moderator: [\"user\"],\n  admin: [\"moderator\"],\n};\n\n// Get all roles for an admin\nconst adminRoles = collectInheritedRoles([\"admin\"], hierarchy);\nconsole.log(adminRoles); // Set { \"admin\", \"moderator\", \"user\", \"guest\" }\n\n// Get all roles for a moderator\nconst modRoles = collectInheritedRoles([\"moderator\"], hierarchy);\nconsole.log(modRoles); // Set { \"moderator\", \"user\", \"guest\" }\n\n// Multiple input roles\nconst mixedRoles = collectInheritedRoles([\"user\", \"beta-tester\"], {\n  ...hierarchy,\n  \"beta-tester\": [],\n});\nconsole.log(mixedRoles); // Set { \"user\", \"guest\", \"beta-tester\" }\n```\n\n## Best Practices\n\n1. **Keep hierarchies simple** ‚Äî Deep hierarchies are hard to reason about\n2. **Document role permissions** ‚Äî Maintain a clear mapping of what each role can do\n3. **Use meaningful role names** ‚Äî \"editor\" is clearer than \"level-3\"\n4. **Avoid circular dependencies** ‚Äî Role A should not inherit from role B if B inherits from A\n5. **Test edge cases** ‚Äî Especially when users have multiple roles\n",
  "packages/permit/policy-rules.md": "# Policy Rules\n\nPolicy rules are functions that determine whether an action is allowed or denied. `@zap-studio/permit` provides three rule builders: `allow()`, `deny()`, and `when()`.\n\n## Understanding Rules\n\nEvery rule in your policy must return a **decision**: either `\"allow\"` or `\"deny\"`. Rules receive three arguments:\n\n1. **context** ‚Äî The current user/request context\n2. **action** ‚Äî The action being performed (e.g., \"read\", \"write\")\n3. **resource** ‚Äî The resource being accessed\n\n## allow()\n\nThe `allow()` function creates a rule that always permits the action, regardless of context or resource.\n\n```typescript\nimport { allow } from \"@zap-studio/permit\";\n```\n\n### When to Use\n\nUse `allow()` for actions that should be available to everyone:\n\n- Public content (published blog posts, product listings)\n- Health check endpoints\n- Public API documentation\n\n### Example: Public Content\n\n```typescript\nimport { createPolicy, allow, when } from \"@zap-studio/permit\";\n\nconst policy = createPolicy<AppContext>({\n  resources,\n  actions,\n  rules: {\n    post: {\n      // Anyone can read posts (we'll refine this with conditions later)\n      read: allow(),\n    },\n    documentation: {\n      // API docs are always public\n      read: allow(),\n    },\n  },\n});\n```\n\n## deny()\n\nThe `deny()` function creates a rule that always blocks the action. No context or resource can override this.\n\n```typescript\nimport { deny } from \"@zap-studio/permit\";\n```\n\n### When to Use\n\nUse `deny()` for:\n\n- Temporarily disabled features\n- Actions reserved for future implementation\n- Hard blocks that should never be bypassed\n\n### Example: Disabled Features\n\n```typescript\nimport { createPolicy, allow, deny, when } from \"@zap-studio/permit\";\n\nconst policy = createPolicy<AppContext>({\n  resources,\n  actions,\n  rules: {\n    post: {\n      read: allow(),\n      write: when((ctx, _, post) => ctx.user?.id === post.authorId),\n      // Permanently archived posts cannot be deleted\n      delete: deny(),\n    },\n    legacyFeature: {\n      // This feature is deprecated and disabled\n      use: deny(),\n    },\n  },\n});\n```\n\n## when()\n\nThe `when()` function creates a conditional rule. It takes a condition function and allows the action only if the condition returns `true`.\n\n```typescript\nimport { when } from \"@zap-studio/permit\";\n\nwhen((context, action, resource) => boolean)\n```\n\n### Condition Function\n\nThe condition function receives:\n\n| Parameter  | Type     | Description                    |\n| ---------- | -------- | ------------------------------ |\n| `context`  | `TContext` | Current user/request context   |\n| `action`   | `string` | The action being performed     |\n| `resource` | `TResource` | The resource being accessed    |\n\nIt must return a `boolean`:\n- `true` ‚Üí action is allowed\n- `false` ‚Üí action is denied\n\n### Example: Owner-Only Access\n\n```typescript\nimport { createPolicy, when } from \"@zap-studio/permit\";\n\nconst policy = createPolicy<AppContext>({\n  resources,\n  actions,\n  rules: {\n    post: {\n      // Only the author can edit their post\n      write: when((ctx, _, post) => ctx.user?.id === post.authorId),\n\n      // Only the author can delete their post\n      delete: when((ctx, _, post) => ctx.user?.id === post.authorId),\n    },\n  },\n});\n```\n\n## Using the Action Parameter\n\nThe `action` parameter becomes useful when you create reusable condition functions that handle multiple actions differently. This lets you share logic across actions while still customizing behavior:\n\n```typescript\nimport { createPolicy, when } from \"@zap-studio/permit\";\nimport type { ConditionFn } from \"@zap-studio/permit/types\";\n\ntype PostAction = \"read\" | \"write\" | \"delete\";\ntype Post = { id: string; authorId: string; visibility: \"public\" | \"private\" };\n\n// Reusable condition that behaves differently based on action\nconst canAccessPost: ConditionFn<AppContext, PostAction, Post> = (ctx, action, post) => {\n  // Anyone can read public posts\n  if (action === \"read\" && post.visibility === \"public\") {\n    return true;\n  }\n\n  // For write/delete (or private reads), must be the author\n  return ctx.user?.id === post.authorId;\n};\n\nconst policy = createPolicy<AppContext>({\n  resources,\n  actions,\n  rules: {\n    post: {\n      // Same function handles all three actions with different logic\n      read: when(canAccessPost),\n      write: when(canAccessPost),\n      delete: when(canAccessPost),\n    },\n  },\n});\n```\n\nThis pattern is useful when actions share similar logic but need slight variations‚Äîyou define the condition once and reuse it across multiple actions.\n\n## Combining Rules\n\nRules can be combined with condition combinators. See the [Conditions](/packages/permit/conditions) page for details on using `and()`, `or()`, and `not()`.\n\n## Best Practices\n\n1. **Start restrictive** ‚Äî Use `deny()` as the default, then explicitly allow\n2. **Keep conditions pure** ‚Äî Don't perform side effects in condition functions\n3. **Avoid async operations** ‚Äî Conditions must be synchronous; fetch data before checking\n4. **Use descriptive variable names** ‚Äî `isOwner`, `isMember`, `hasAccess`\n5. **Extract complex conditions** ‚Äî Create reusable condition functions for clarity\n",
  "packages/permit/merging-policies.md": "# Merging Policies\n\nAs your application grows, you may want to organize authorization logic into separate policies. `@zap-studio/permit` provides two strategies for merging policies: deny-overrides and allow-overrides.\n\n## Why Merge Policies?\n\nMerging policies is useful when:\n\n- **Separation of concerns** ‚Äî Keep domain-specific rules in separate files\n- **Layered security** ‚Äî Apply base rules that can be tightened or relaxed\n- **Feature flags** ‚Äî Enable/disable features by adding or removing policies\n- **Multi-tenancy** ‚Äî Combine organization policies with application policies\n\n## mergePolicies() ‚Äî Deny-Overrides Strategy\n\nThe `mergePolicies()` function combines policies using a deny-overrides strategy. An action is allowed only if **all** policies allow it.\n\n```typescript\nimport { mergePolicies } from \"@zap-studio/permit\";\n\nconst mergedPolicy = mergePolicies(policy1, policy2, policy3);\n```\n\nThink of it as an AND operation: `policy1 AND policy2 AND policy3`\n\n### Behavior\n\n| Policy 1 | Policy 2 | Result  |\n| -------- | -------- | ------- |\n| allow    | allow    | allow   |\n| allow    | deny     | **deny** |\n| deny     | allow    | **deny** |\n| deny     | deny     | deny    |\n\n### Example: Base + Restrictive Policy\n\n```typescript\nimport { z } from \"zod\";\nimport { createPolicy, when, mergePolicies, allow } from \"@zap-studio/permit\";\nimport type { Resources, Actions } from \"@zap-studio/permit/types\";\n\nconst resources = {\n  document: z.object({\n    id: z.string(),\n    ownerId: z.string(),\n    classification: z.enum([\"public\", \"internal\", \"confidential\"]),\n  }),\n} satisfies Resources;\n\nconst actions = {\n  document: [\"read\", \"write\", \"delete\"],\n} as const satisfies Actions<typeof resources>;\n\ntype AppContext = {\n  user: { id: string; clearanceLevel: number } | null;\n};\n\n// Base policy: standard access rules\nconst basePolicy = createPolicy<AppContext>({\n  resources,\n  actions,\n  rules: {\n    document: {\n      read: when((ctx, _, doc) =>\n        doc.classification === \"public\" || ctx.user?.id === doc.ownerId\n      ),\n      write: when((ctx, _, doc) => ctx.user?.id === doc.ownerId),\n      delete: when((ctx, _, doc) => ctx.user?.id === doc.ownerId),\n    },\n  },\n});\n\n// Security policy: additional clearance requirements\nconst securityPolicy = createPolicy<AppContext>({\n  resources,\n  actions,\n  rules: {\n    document: {\n      read: when((ctx, _, doc) => {\n        if (doc.classification === \"confidential\") {\n          return (ctx.user?.clearanceLevel ?? 0) >= 3;\n        }\n        if (doc.classification === \"internal\") {\n          return (ctx.user?.clearanceLevel ?? 0) >= 1;\n        }\n        return true; // Public documents have no clearance requirement\n      }),\n      write: when((ctx, _, doc) => {\n        if (doc.classification === \"confidential\") {\n          return (ctx.user?.clearanceLevel ?? 0) >= 3;\n        }\n        return true;\n      }),\n      delete: when((ctx, _, doc) => {\n        // Only high clearance can delete confidential docs\n        if (doc.classification === \"confidential\") {\n          return (ctx.user?.clearanceLevel ?? 0) >= 4;\n        }\n        return true;\n      }),\n    },\n  },\n});\n\n// Merge: both policies must allow\nconst policy = mergePolicies(basePolicy, securityPolicy);\n\n// Usage\nconst confidentialDoc = {\n  id: \"doc-1\",\n  ownerId: \"user-123\",\n  classification: \"confidential\" as const,\n};\n\n// Owner with low clearance: base allows, security denies ‚Üí DENIED\nconst lowClearanceOwner: AppContext = {\n  user: { id: \"user-123\", clearanceLevel: 1 },\n};\nconsole.log(policy.can(lowClearanceOwner, \"read\", \"document\", confidentialDoc)); // false\n\n// Owner with high clearance: both allow ‚Üí ALLOWED\nconst highClearanceOwner: AppContext = {\n  user: { id: \"user-123\", clearanceLevel: 3 },\n};\nconsole.log(policy.can(highClearanceOwner, \"read\", \"document\", confidentialDoc)); // true\n```\n\n## mergePoliciesAny() ‚Äî Allow-Overrides Strategy\n\nThe `mergePoliciesAny()` function combines policies using an allow-overrides strategy. An action is allowed if **any** policy allows it.\n\n```typescript\nimport { mergePoliciesAny } from \"@zap-studio/permit\";\n\nconst mergedPolicy = mergePoliciesAny(policy1, policy2, policy3);\n```\n\nThink of it as an OR operation: `policy1 OR policy2 OR policy3`\n\n### Behavior\n\n| Policy 1 | Policy 2 | Result    |\n| -------- | -------- | --------- |\n| allow    | allow    | allow     |\n| allow    | deny     | **allow** |\n| deny     | allow    | **allow** |\n| deny     | deny     | deny      |\n\n### Example: Multiple Access Paths\n\n```typescript\nimport { z } from \"zod\";\nimport { createPolicy, when, mergePoliciesAny, allow } from \"@zap-studio/permit\";\nimport type { Resources, Actions } from \"@zap-studio/permit/types\";\n\nconst resources = {\n  file: z.object({\n    id: z.string(),\n    ownerId: z.string(),\n    isPublic: z.boolean(),\n    sharedWith: z.array(z.string()),\n    teamId: z.string().nullable(),\n  }),\n} satisfies Resources;\n\nconst actions = {\n  file: [\"read\", \"write\", \"delete\"],\n} as const satisfies Actions<typeof resources>;\n\ntype FileContext = {\n  user: { id: string; teamIds: string[] } | null;\n};\n\n// Owner access policy\nconst ownerPolicy = createPolicy<FileContext>({\n  resources,\n  actions,\n  rules: {\n    file: {\n      read: when((ctx, _, file) => ctx.user?.id === file.ownerId),\n      write: when((ctx, _, file) => ctx.user?.id === file.ownerId),\n      delete: when((ctx, _, file) => ctx.user?.id === file.ownerId),\n    },\n  },\n});\n\n// Public access policy\nconst publicPolicy = createPolicy<FileContext>({\n  resources,\n  actions,\n  rules: {\n    file: {\n      read: when((_, __, file) => file.isPublic),\n      write: when(() => false), // Public doesn't grant write\n      delete: when(() => false), // Public doesn't grant delete\n    },\n  },\n});\n\n// Shared access policy\nconst sharedPolicy = createPolicy<FileContext>({\n  resources,\n  actions,\n  rules: {\n    file: {\n      read: when((ctx, _, file) => file.sharedWith.includes(ctx.user?.id ?? \"\")),\n      write: when((ctx, _, file) => file.sharedWith.includes(ctx.user?.id ?? \"\")),\n      delete: when(() => false), // Shared users can't delete\n    },\n  },\n});\n\n// Team access policy\nconst teamPolicy = createPolicy<FileContext>({\n  resources,\n  actions,\n  rules: {\n    file: {\n      read: when((ctx, _, file) =>\n        file.teamId !== null && ctx.user?.teamIds.includes(file.teamId)\n      ),\n      write: when((ctx, _, file) =>\n        file.teamId !== null && ctx.user?.teamIds.includes(file.teamId)\n      ),\n      delete: when(() => false), // Team members can't delete\n    },\n  },\n});\n\n// Any of these policies can grant access\nconst filePolicy = mergePoliciesAny(ownerPolicy, publicPolicy, sharedPolicy, teamPolicy);\n\n// Usage\nconst file = {\n  id: \"file-1\",\n  ownerId: \"user-owner\",\n  isPublic: false,\n  sharedWith: [\"user-shared\"],\n  teamId: \"team-1\",\n};\n\n// User with shared access can read\nconst sharedUser: FileContext = {\n  user: { id: \"user-shared\", teamIds: [] },\n};\nconsole.log(filePolicy.can(sharedUser, \"read\", \"file\", file)); // true (via sharedPolicy)\nconsole.log(filePolicy.can(sharedUser, \"write\", \"file\", file)); // true (via sharedPolicy)\nconsole.log(filePolicy.can(sharedUser, \"delete\", \"file\", file)); // false (no policy allows)\n\n// Team member can also read/write\nconst teamMember: FileContext = {\n  user: { id: \"user-team\", teamIds: [\"team-1\"] },\n};\nconsole.log(filePolicy.can(teamMember, \"read\", \"file\", file)); // true (via teamPolicy)\n```\n\n## Combining Both Strategies\n\nYou can combine `mergePolicies` and `mergePoliciesAny` for complex scenarios:\n\n```typescript\nimport { mergePolicies, mergePoliciesAny } from \"@zap-studio/permit\";\n\n// Access layer: multiple paths to access\nconst accessPolicy = mergePoliciesAny(ownerPolicy, sharedPolicy, publicPolicy);\n\n// Security layer: must pass all security checks\nconst securityPolicy = mergePolicies(auditPolicy, compliancePolicy, ratePolicy);\n\n// Final policy: must have access AND pass security\nconst finalPolicy = mergePolicies(accessPolicy, securityPolicy);\n```\n\n### Visualization\n\n```\n                   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n                   ‚îÇ finalPolicy ‚îÇ\n                   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n                          ‚îÇ AND (mergePolicies)\n            ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n            ‚îÇ                           ‚îÇ\n     ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê             ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n     ‚îÇaccessPolicy ‚îÇ             ‚îÇsecurityPolicy‚îÇ\n     ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò             ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n            ‚îÇ OR                        ‚îÇ AND\n    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê           ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n    ‚îÇ       ‚îÇ       ‚îÇ           ‚îÇ       ‚îÇ       ‚îÇ\n owner   shared   public     audit  compliance rate\n```\n\n## Empty Policy Arrays\n\n- Calling `mergePolicies()` without any policies returns `false` (denies by default).\n- Calling `mergePoliciesAny()` without any policies also returns `false` (denies by default).\n\n```typescript\nconst emptyAnd = mergePolicies(); // Always denies\nconst emptyOr = mergePoliciesAny(); // Always denies\n```\n\n## Best Practices\n\n1. **Name policies descriptively** ‚Äî `securityPolicy`, `ownerAccessPolicy`, `compliancePolicy`\n2. **Keep policies focused** ‚Äî Each policy should handle one concern\n3. **Document merge order** ‚Äî Explain why policies are merged in a specific order\n4. **Test merged policies** ‚Äî Ensure the combined behavior is correct\n5. **Consider performance** ‚Äî Fewer policies means fewer checks\n",
  "packages/permit/index.md": "# @zap-studio/permit\n\nAuthorization logic often ends up scattered across your codebase‚Äîburied in route handlers, middleware, and components.\n\nThis makes it hard to maintain, test, and audit. Every application needs to answer one question: **\"Can this user do this action on this resource?\"**\n\nMost developers handle this with scattered `if` statements‚Äîchecking roles in route handlers, ownership in services, and permissions in components. This approach creates problems:\n\n- **Duplicated logic** ‚Äî The same checks written in multiple places\n- **Hard to audit** ‚Äî No single source of truth for \"who can do what\"\n- **Easy to forget** ‚Äî New endpoints might miss authorization entirely\n- **Difficult to test** ‚Äî Authorization is tangled with business logic\n\n`@zap-studio/permit` solves this by letting you define all your authorization rules in one place, with full type safety and composable building blocks.\n\n## Why @zap-studio/permit?\n\n**Before:**\n\n```typescript\n// Authorization logic scattered everywhere\napp.delete(\"/posts/:id\", async (req, res) => {\n  const post = await getPost(req.params.id);\n  const user = req.user;\n\n  // üò± Logic duplicated across routes\n  if (user.role !== \"admin\" && post.authorId !== user.id) {\n    return res.status(403).json({ error: \"Forbidden\" });\n  }\n\n  await deletePost(post.id);\n  res.json({ success: true });\n});\n```\n\n**After:**\n\n```typescript\nimport { createPolicy, when, or, hasRole } from \"@zap-studio/permit\";\n\n// ‚ú® Centralized, declarative authorization\nconst policy = createPolicy<AppContext>({\n  resources,\n  actions,\n  rules: {\n    post: {\n      delete: when(\n        or(\n          hasRole(\"admin\"),\n          (ctx, _, post) => ctx.user.id === post.authorId\n        )\n      ),\n    },\n  },\n});\n\n// Clean route handler\napp.delete(\"/posts/:id\", async (req, res) => {\n  const post = await getPost(req.params.id);\n\n  if (!policy.can(req.context, \"delete\", \"post\", post)) {\n    return res.status(403).json({ error: \"Forbidden\" });\n  }\n\n  await deletePost(post.id);\n  res.json({ success: true });\n});\n```\n\n## Features\n\n- **Declarative policies** ‚Äî Define authorization rules in one place\n- **Type-safe** ‚Äî Full TypeScript inference for resources, actions, and context\n- **Standard Schema validation** ‚Äî Validates resources at runtime using your schemas\n- **Composable conditions** ‚Äî Build complex rules with `and()`, `or()`, `not()`\n- **Role hierarchies** ‚Äî Support inherited permissions with `hasRole()`\n- **Policy merging** ‚Äî Combine multiple policies with different strategies\n- **Framework agnostic** ‚Äî Works with Express, Hono, Elysia, Fastify, Next.js, TanStack Start or any framework\n\n## Installation\n\n```bash\npnpm add @zap-studio/permit\n# or\nnpm install @zap-studio/permit\n```\n\n## Quick Start\n\nLet's build authorization for a simple blog where users can read public posts, but only authors can edit their own posts.\n\n### 1. Define Your Resources\n\nFirst, define the shape of your resources using any Standard Schema library. You can re-use existing schemas or create new ones.\n\n```typescript\nimport { z } from \"zod\";\nimport type { Resources, Actions } from \"@zap-studio/permit/types\";\n\nconst resources = {\n  post: z.object({\n    id: z.string(),\n    authorId: z.string(),\n    visibility: z.enum([\"public\", \"private\"]),\n  }),\n} satisfies Resources;\n\nconst actions = {\n  post: [\"read\", \"write\", \"delete\"],\n} as const satisfies Actions<typeof resources>;\n```\n\nFor instance, in the above example, we define a `post` resource that includes an `id`, `authorId`, and `visibility`.\n\nThe associated actions for this resource are `read`, `write`, or `delete`. Indeed, all resources should be defined with a set of actions that are relevant to the resource.\n\n### 2. Create Your Policy\n\nThen, we can define the authorization rules for each resource and action. For that, we need to provide a `context` object that contains information about the current user and their role.\n\n```typescript\nimport { createPolicy, allow, when, or } from \"@zap-studio/permit\";\n\ntype AppContext = {\n  user: { id: string; role: \"guest\" | \"user\" | \"admin\" } | null;\n};\n\nconst policy = createPolicy<AppContext>({\n  resources,\n  actions,\n  rules: {\n    post: {\n      // Anyone can read public posts, authors can read their private posts\n      read: when(\n        or(\n          (_ctx, _action, post) => post.visibility === \"public\",\n          (ctx, _action, post) => ctx.user?.id === post.authorId\n        )\n      ),\n      // Only authors can write their posts\n      write: when((ctx, _, post) => ctx.user?.id === post.authorId),\n      // Only authors can delete their posts\n      delete: when((ctx, _, post) => ctx.user?.id === post.authorId),\n    },\n  },\n});\n```\n\nThe above policy defines the authorization rules for the `post` resource. It allows anyone to read public posts and authors to read their private posts. Only authors can write or delete their posts.\n\n### 3. Check Permissions\n\nFinally, you can use `policy.can()` to check if an action is allowed:\n\n```typescript\nconst post = {\n  id: \"post-1\",\n  authorId: \"user-123\",\n  visibility: \"public\" as const,\n};\n\nconst context: AppContext = {\n  user: { id: \"user-456\", role: \"user\" },\n};\n\n// Check if the user can read this post\nif (policy.can(context, \"read\", \"post\", post)) {\n  console.log(\"Access granted!\");\n} else {\n  console.log(\"Access denied.\");\n}\n```\n\nUsing this approach, you get an awesome way to manage access control in your application. Everything is type-safe, easy to understand and centralized.\n\n## What's Next?\n\n- [Creating Policies](/packages/permit/creating-policies) ‚Äî Learn about resources, actions, and policy creation\n- [Policy Rules](/packages/permit/policy-rules) ‚Äî Master `allow()`, `deny()`, and `when()`\n- [Conditions](/packages/permit/conditions) ‚Äî Build complex rules with combinators\n- [Role-Based Access Control](/packages/permit/roles) ‚Äî Implement role hierarchies\n- [Merging Policies](/packages/permit/merging-policies) ‚Äî Compose multiple policies\n- [Error Handling](/packages/permit/errors) ‚Äî Handle policy errors gracefully\n",
  "packages/permit/errors.md": "# Error Handling\n\n`@zap-studio/permit` provides utilities for handling errors and ensuring exhaustive type checking in your authorization logic.\n\n## PolicyError\n\nThe `PolicyError` class is a custom error type for policy-related errors. Use it to distinguish authorization errors from other application errors.\n\n```typescript\nimport { PolicyError } from \"@zap-studio/permit/errors\";\n```\n\n### Properties\n\n| Property  | Type     | Description              |\n| --------- | -------- | ------------------------ |\n| `name`    | `string` | Always `\"PolicyError\"`   |\n| `message` | `string` | Error description        |\n| `stack`   | `string` | Stack trace (inherited)  |\n\n### Creating Policy Errors\n\n```typescript\nimport { PolicyError } from \"@zap-studio/permit/errors\";\n\n// Throw when an authorization check fails\nthrow new PolicyError(\"User is not authorized to delete this resource\");\n\n// Throw for invalid policy configuration\nthrow new PolicyError(\"Unknown resource type: 'invalid'\");\n\n// Throw for missing context\nthrow new PolicyError(\"User context is required for this action\");\n```\n\n### Catching Policy Errors\n\n```typescript\nimport { PolicyError } from \"@zap-studio/permit/errors\";\n\nasync function deletePost(postId: string, context: AppContext) {\n  try {\n    const post = await getPost(postId);\n\n    if (!policy.can(context, \"delete\", \"post\", post)) {\n      throw new PolicyError(\"Not authorized to delete this post\");\n    }\n\n    await db.posts.delete(postId);\n    return { success: true };\n  } catch (error) {\n    if (error instanceof PolicyError) {\n      // Handle authorization errors\n      return { success: false, error: error.message, code: \"FORBIDDEN\" };\n    }\n\n    // Re-throw unexpected errors\n    throw error;\n  }\n}\n```\n\n## assertNever\n\nThe `assertNever()` helper ensures exhaustive type checking in TypeScript. It causes a compile-time error if a switch statement or if-else chain doesn't handle all possible cases.\n\n```typescript\nimport { assertNever } from \"@zap-studio/permit/helpers\";\n```\n\n### How It Works\n\n`assertNever()` accepts a value of type `never`. If TypeScript can prove that a value could reach `assertNever()`, it means you've missed a case.\n\n### Example: Exhaustive Action Handling\n\n```typescript\nimport { assertNever } from \"@zap-studio/permit/helpers\";\n\ntype Action = \"read\" | \"write\" | \"delete\";\n\nfunction getPermissionLevel(action: Action): number {\n  switch (action) {\n    case \"read\":\n      return 1;\n    case \"write\":\n      return 2;\n    case \"delete\":\n      return 3;\n    default:\n      // TypeScript error if we forget a case\n      return assertNever(action);\n  }\n}\n```\n\nIf you add a new action without updating the switch:\n\n```typescript\ntype Action = \"read\" | \"write\" | \"delete\" | \"archive\"; // Added \"archive\"\n\nfunction getPermissionLevel(action: Action): number {\n  switch (action) {\n    case \"read\":\n      return 1;\n    case \"write\":\n      return 2;\n    case \"delete\":\n      return 3;\n    default:\n      // TypeScript ERROR: Argument of type 'string' is not assignable to parameter of type 'never'.\n      return assertNever(action);\n  }\n}\n```\n\n### Runtime Behavior\n\nIf `assertNever()` is reached at runtime (e.g., due to type assertions or JavaScript calling the function), it throws an error:\n\n```typescript\nimport { assertNever } from \"@zap-studio/permit/helpers\";\n\n// This would throw: Error: Unexpected value: unknown\nconst badValue = \"unknown\" as never;\nassertNever(badValue);\n```\n\n## Best Practices\n\n1. **Use `PolicyError` for authorization failures** ‚Äî Makes it easy to distinguish from other errors\n2. **Catch errors at boundaries** ‚Äî Handle `PolicyError` in middleware or API handlers\n3. **Include context in error messages** ‚Äî \"Not authorized to delete post-123\" is better than \"Forbidden\"\n4. **Use `assertNever` for exhaustive checks** ‚Äî Especially when handling actions or resource types\n5. **Log denied attempts** ‚Äî Track authorization failures for security monitoring\n",
  "packages/permit/creating-policies.md": "# Creating Policies\n\nA policy is the core building block of `@zap-studio/permit`. It defines what actions users can perform on your application's resources based on the current context.\n\n## Understanding Policies\n\nThink of a policy as a rulebook that answers questions like:\n\n- \"Can this user edit this blog post?\"\n- \"Can a guest view this private document?\"\n- \"Can an admin delete any comment?\"\n\nA policy consists of three parts:\n\n1. **Resources** ‚Äî The things being protected (posts, comments, users)\n2. **Actions** ‚Äî What can be done with resources (read, write, delete)\n3. **Rules** ‚Äî The logic that determines if an action is allowed\n\n::: tip\nWe recommend defining resources and actions in a centralized location to ensure consistency and type safety.\n:::\n\n## Defining Resources\n\nResources are defined using [Standard Schema](https://standardschema.dev/), which means you can use Zod, Valibot, ArkType, or any compatible library.\n\n### Using Zod\n\n```typescript\nimport { z } from \"zod\";\nimport type { Resources } from \"@zap-studio/permit/types\";\n\nconst resources = {\n  post: z.object({\n    id: z.string(),\n    authorId: z.string(),\n    title: z.string(),\n    visibility: z.enum([\"public\", \"private\", \"draft\"]),\n    createdAt: z.date(),\n  }),\n  comment: z.object({\n    id: z.string(),\n    postId: z.string(),\n    authorId: z.string(),\n    content: z.string(),\n  }),\n  user: z.object({\n    id: z.string(),\n    email: z.string().email(),\n    role: z.enum([\"guest\", \"user\", \"admin\"]),\n  }),\n} satisfies Resources;\n```\n\n### Using Valibot\n\n```typescript\nimport * as v from \"valibot\";\nimport type { Resources } from \"@zap-studio/permit/types\";\n\nconst resources = {\n  post: v.object({\n    id: v.string(),\n    authorId: v.string(),\n    visibility: v.picklist([\"public\", \"private\"]),\n  }),\n} satisfies Resources;\n```\n\n### Using ArkType\n\n```typescript\nimport { type } from \"arktype\";\nimport type { Resources } from \"@zap-studio/permit/types\";\n\nconst resources = {\n  post: type({\n    id: \"string\",\n    authorId: \"string\",\n    visibility: \"'public' | 'private'\",\n  }),\n} satisfies Resources;\n```\n\n::: warning\nYou should use `satisfies` to ensure type safety and consistency. Learn more about the [TypeScript `satisfies` operator](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-9.html#the-satisfies-operator).\n:::\n\n## Defining Actions\n\nActions specify what operations are allowed on each resource. Define them as readonly arrays:\n\n```typescript\nimport type { Actions } from \"@zap-studio/permit/types\";\n\nconst actions = {\n  post: [\"read\", \"write\", \"delete\", \"publish\"],\n  comment: [\"read\", \"write\", \"delete\"],\n  user: [\"read\", \"update\", \"delete\", \"ban\"],\n} as const satisfies Actions<typeof resources>;\n```\n\n::: warning\nUse `as const` to ensure TypeScript infers literal types for actions. This enables autocomplete and type checking when writing rules. Learn more about the [TypeScript `as const` operator](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-4.html#const-assertions).\n:::\n\n## Understanding Context\n\nContext represents the runtime information available when checking permissions. This typically includes the current user, but can contain anything relevant to authorization:\n\n```typescript\ntype AppContext = {\n  user: {\n    id: string;\n    role: \"guest\" | \"user\" | \"admin\";\n    permissions: string[];\n    organizationId: string;\n  } | null;\n  request?: {\n    ip: string;\n    userAgent: string;\n  };\n  timestamp: Date;\n};\n```\n\nContext is passed to `policy.can()` at runtime and is available in all your rule functions.\n\n::: tip\nContext is just a type that represents the runtime information available when checking permissions. It can be anything relevant to your application's authorization needs. Providing context will make your experience way better. Believe me, it's worth it!\n:::\n\n## Creating a Policy\n\nFinally, a policy defines the rules that govern access to resources for each action. It uses the resources and actions defined earlier.\n\nUse `createPolicy()` to create a policy:\n\n```typescript\nimport { createPolicy, allow, deny, when } from \"@zap-studio/permit\";\n\nconst policy = createPolicy<AppContext>({\n  resources,\n  actions,\n  rules: {\n    post: {\n      read: allow(),\n      write: when((ctx, _action, post) => ctx.user?.id === post.authorId),\n      delete: deny(),\n      publish: when((ctx) => ctx.user?.role === \"admin\"),\n    },\n    comment: {\n      read: allow(),\n      write: when((ctx) => ctx.user !== null),\n      delete: when((ctx, _action, comment) => ctx.user?.id === comment.authorId),\n    },\n  },\n});\n```\n\n## Checking Permissions\n\nThe policy object provides a `can()` method to check if an action is allowed. It takes the `context`, `action`, `resourceType`, and `resource` as parameters and returns a boolean indicating whether the action is allowed.\n\n```typescript\npolicy.can(context, action, resourceType, resource): boolean\n```\n\n### Parameters\n\n| Parameter      | Type     | Description                              |\n| -------------- | -------- | ---------------------------------------- |\n| `context`      | `TContext` | The current context (user, request, etc.) |\n| `action`       | `string` | The action to check (e.g., \"read\", \"write\") |\n| `resourceType` | `string` | The type of resource (e.g., \"post\", \"comment\") |\n| `resource`     | `object` | The actual resource being accessed       |\n\n### Example: Blog Post Authorization\n\nHere is a complete example for a blog application:\n\n```typescript\n// Scenario: User trying to edit a blog post\nconst context: AppContext = {\n  user: { id: \"user-123\", role: \"user\", permissions: [], organizationId: \"org-1\" },\n  timestamp: new Date(),\n};\n\nconst post = {\n  id: \"post-456\",\n  authorId: \"user-123\", // Same as context.user.id (so user is the author)\n  title: \"My First Post\",\n  visibility: \"public\" as const,\n  createdAt: new Date(),\n};\n\n// The user is the author, so this returns true according to the policy\nconst canEdit = policy.can(context, \"write\", \"post\", post);\nconsole.log(canEdit); // true\n\n// A different user trying to edit\nconst otherContext: AppContext = {\n  user: { id: \"user-789\", role: \"user\", permissions: [], organizationId: \"org-1\" },\n  timestamp: new Date(),\n};\n\nconst canOtherEdit = policy.can(otherContext, \"write\", \"post\", post);\nconsole.log(canOtherEdit); // false\n```\n\n## Real-World Example: E-commerce Store\n\nHere's another complete example for an e-commerce application:\n\n```typescript\nimport { z } from \"zod\";\nimport { createPolicy, allow, deny, when, or } from \"@zap-studio/permit\";\nimport type { Resources, Actions } from \"@zap-studio/permit/types\";\n\n// Define resources\nconst resources = {\n  product: z.object({\n    id: z.string(),\n    sellerId: z.string(),\n    price: z.number(),\n    status: z.enum([\"draft\", \"published\", \"archived\"]),\n  }),\n  order: z.object({\n    id: z.string(),\n    customerId: z.string(),\n    sellerId: z.string(),\n    status: z.enum([\"pending\", \"paid\", \"shipped\", \"delivered\"]),\n  }),\n  review: z.object({\n    id: z.string(),\n    productId: z.string(),\n    customerId: z.string(),\n    rating: z.number().min(1).max(5),\n  }),\n} satisfies Resources;\n\nconst actions = {\n  product: [\"read\", \"create\", \"update\", \"delete\", \"publish\"],\n  order: [\"read\", \"create\", \"update\", \"cancel\"],\n  review: [\"read\", \"create\", \"update\", \"delete\"],\n} as const satisfies Actions<typeof resources>;\n\ntype StoreContext = {\n  user: {\n    id: string;\n    role: \"customer\" | \"seller\" | \"admin\";\n  } | null;\n};\n\nconst storePolicy = createPolicy<StoreContext>({\n  resources,\n  actions,\n  rules: {\n    product: {\n      // Anyone can read published products\n      read: when((_, __, product) => product.status === \"published\"),\n      // Only sellers can create products\n      create: when((ctx) => ctx.user?.role === \"seller\"),\n      // Sellers can update their own products\n      update: when(\n        (ctx, _, product) =>\n          ctx.user?.role === \"seller\" && ctx.user.id === product.sellerId\n      ),\n      // Only admins can delete products\n      delete: when((ctx) => ctx.user?.role === \"admin\"),\n      // Sellers can publish their own products\n      publish: when(\n        (ctx, _, product) =>\n          ctx.user?.role === \"seller\" && ctx.user.id === product.sellerId\n      ),\n    },\n    order: {\n      // Customers see their orders, sellers see orders for their products\n      read: when(\n        or(\n          (ctx, _, order) => ctx.user?.id === order.customerId,\n          (ctx, _, order) => ctx.user?.id === order.sellerId\n        )\n      ),\n      // Only authenticated customers can create orders\n      create: when((ctx) => ctx.user?.role === \"customer\"),\n      // Sellers can update order status\n      update: when((ctx, _, order) => ctx.user?.id === order.sellerId),\n      // Customers can cancel pending orders\n      cancel: when(\n        (ctx, _, order) =>\n          ctx.user?.id === order.customerId && order.status === \"pending\"\n      ),\n    },\n    review: {\n      // Anyone can read reviews\n      read: allow(),\n      // Customers can create reviews\n      create: when((ctx) => ctx.user?.role === \"customer\"),\n      // Customers can update their own reviews\n      update: when((ctx, _, review) => ctx.user?.id === review.customerId),\n      // Customers can delete their reviews, admins can delete any\n      delete: when(\n        or(\n          (ctx, _, review) => ctx.user?.id === review.customerId,\n          (ctx) => ctx.user?.role === \"admin\"\n        )\n      ),\n    },\n  },\n});\n\n// Usage\nconst product = {\n  id: \"prod-1\",\n  sellerId: \"seller-123\",\n  price: 99.99,\n  status: \"published\" as const,\n};\n\nconst customerContext: StoreContext = {\n  user: { id: \"customer-456\", role: \"customer\" },\n};\n\nconsole.log(storePolicy.can(customerContext, \"read\", \"product\", product)); // true\nconsole.log(storePolicy.can(customerContext, \"update\", \"product\", product)); // false\n```\n\n## Best Practices\n\n1. **Keep resources focused** ‚Äî Each resource should represent a single domain entity\n2. **Use descriptive action names** ‚Äî \"publish\" is clearer than \"update-status\"\n3. **Include all relevant data in context** ‚Äî Don't fetch additional data inside rules\n4. **Start with `deny()` by default** ‚Äî Be explicit about what's allowed\n5. **Test your policies** ‚Äî Write unit tests for critical authorization rules\n",
  "packages/permit/conditions.md": "# Conditions\n\nConditions are the building blocks for creating complex authorization rules. `@zap-studio/permit` provides combinators to compose simple conditions into powerful, readable policies.\n\n## Understanding Conditions\n\nA condition is a function that evaluates to `true` or `false`:\n\n```typescript\ntype ConditionFn<TContext, TAction, TResource> = (\n  context: TContext,\n  action: TAction,\n  resource: TResource\n) => boolean;\n```\n\nConditions are used with `when()` to create policy rules:\n\n```typescript\nwhen((ctx, action, resource) => /* condition logic */)\n```\n\n## Condition Combinators\n\n### and()\n\nThe `and()` combinator creates a condition that passes only when **all** conditions are true. It short-circuits on the first `false` value.\n\n```typescript\nimport { and } from \"@zap-studio/permit\";\n\nand(...conditions)\n```\n\n#### Example: Multiple Requirements\n\n```typescript\nimport { createPolicy, when, and } from \"@zap-studio/permit\";\n\n// User must be authenticated AND be the owner AND post must be published\nconst canEditPublishedPost = and(\n  (ctx) => ctx.user !== null,\n  (ctx, _, post) => ctx.user?.id === post.authorId,\n  (_, __, post) => post.status === \"published\"\n);\n\nconst policy = createPolicy<AppContext>({\n  resources,\n  actions,\n  rules: {\n    post: {\n      edit: when(canEditPublishedPost),\n    },\n  },\n});\n```\n\n### or()\n\nThe `or()` combinator creates a condition that passes when **any** condition is true. It short-circuits on the first `true` value.\n\n```typescript\nimport { or } from \"@zap-studio/permit\";\n\nor(...conditions)\n```\n\n#### Example: Multiple Access Paths\n\n```typescript\nimport { createPolicy, when, or } from \"@zap-studio/permit\";\n\n// User can access if they're the owner OR an admin OR explicitly shared\nconst canAccess = or(\n  (ctx, _, doc) => ctx.user?.id === doc.ownerId,\n  (ctx) => ctx.user?.role === \"admin\",\n  (ctx, _, doc) => doc.sharedWith.includes(ctx.user?.id ?? \"\")\n);\n\nconst policy = createPolicy<AppContext>({\n  resources,\n  actions,\n  rules: {\n    document: {\n      read: when(canAccess),\n    },\n  },\n});\n```\n\n### not()\n\nThe `not()` combinator negates a condition.\n\n```typescript\nimport { not } from \"@zap-studio/permit\";\n\nnot(condition)\n```\n\n#### Example: Exclusion Rules\n\n```typescript\nimport { createPolicy, when, not, and } from \"@zap-studio/permit\";\n\n// Cannot interact with your own content\nconst isNotOwner = not((ctx, _, resource) => ctx.user?.id === resource.authorId);\n\n// Content is not archived\nconst isNotArchived = not((_, __, resource) => resource.status === \"archived\");\n\nconst policy = createPolicy<AppContext>({\n  resources,\n  actions,\n  rules: {\n    post: {\n      // Can like any post except your own\n      like: when(isNotOwner),\n\n      // Can comment on posts that aren't archived\n      comment: when(isNotArchived),\n\n      // Can report posts that: you don't own AND aren't already reported by you\n      report: when(\n        and(\n          isNotOwner,\n          (ctx, _, post) => !post.reportedBy.includes(ctx.user?.id ?? \"\")\n        )\n      ),\n    },\n  },\n});\n```\n\n### has()\n\nThe `has()` helper creates a condition that checks if a context property equals a specific value.\n\n```typescript\nimport { has } from \"@zap-studio/permit\";\n\nhas(key, value)\n```\n\n#### Example: Simple Property Checks\n\n```typescript\nimport { createPolicy, when, has, or } from \"@zap-studio/permit\";\n\ntype AppContext = {\n  role: \"guest\" | \"user\" | \"admin\";\n  isVerified: boolean;\n  plan: \"free\" | \"pro\" | \"enterprise\";\n};\n\nconst policy = createPolicy<AppContext>({\n  resources,\n  actions,\n  rules: {\n    settings: {\n      // Only admins can access settings\n      read: when(has(\"role\", \"admin\")),\n    },\n    billing: {\n      // Only verified users can access billing\n      read: when(has(\"isVerified\", true)),\n    },\n    export: {\n      // Pro or Enterprise users can export\n      use: when(or(has(\"plan\", \"pro\"), has(\"plan\", \"enterprise\"))),\n    },\n  },\n});\n```\n\n## Combining Combinators\n\nCombinators can be nested to create complex conditions:\n\n```typescript\nimport { createPolicy, when, and, or, not } from \"@zap-studio/permit\";\n\nconst policy = createPolicy<AppContext>({\n  resources,\n  actions,\n  rules: {\n    document: {\n      // Can edit if:\n      // (owner OR admin) AND (not archived) AND (not locked OR is admin)\n      edit: when(\n        and(\n          or(\n            (ctx, _, doc) => ctx.user?.id === doc.ownerId,\n            (ctx) => ctx.user?.role === \"admin\"\n          ),\n          not((_, __, doc) => doc.status === \"archived\"),\n          or(\n            not((_, __, doc) => doc.isLocked),\n            (ctx) => ctx.user?.role === \"admin\"\n          )\n        )\n      ),\n    },\n  },\n});\n```\n\n## Extracting Reusable Conditions\n\nFor cleaner code, extract conditions into named functions:\n\n```typescript\nimport { and, or, not } from \"@zap-studio/permit\";\nimport type { ConditionFn } from \"@zap-studio/permit/types\";\n\ntype DocContext = {\n  user: { id: string; role: string } | null;\n};\n\ntype Document = {\n  ownerId: string;\n  status: string;\n  isLocked: boolean;\n};\n\n// Reusable conditions\nconst isOwner: ConditionFn<DocContext, string, Document> = (ctx, _, doc) =>\n  ctx.user?.id === doc.ownerId;\n\nconst isAdmin: ConditionFn<DocContext, string, Document> = (ctx) =>\n  ctx.user?.role === \"admin\";\n\nconst isArchived: ConditionFn<DocContext, string, Document> = (_, __, doc) =>\n  doc.status === \"archived\";\n\nconst isLocked: ConditionFn<DocContext, string, Document> = (_, __, doc) =>\n  doc.isLocked;\n\n// Composed conditions\nconst canEdit = and(\n  or(isOwner, isAdmin),\n  not(isArchived),\n  or(not(isLocked), isAdmin)\n);\n\n// Use in policy\nconst policy = createPolicy<DocContext>({\n  resources,\n  actions,\n  rules: {\n    document: {\n      edit: when(canEdit),\n    },\n  },\n});\n```\n\n## Best Practices\n\n1. **Name your conditions** ‚Äî Extract complex logic into well-named functions\n2. **Keep conditions simple** ‚Äî Each condition should check one thing\n3. **Use short-circuit evaluation** ‚Äî Put fast/common checks first in `and()`/`or()`\n4. **Avoid side effects** ‚Äî Conditions should be pure functions\n5. **Document complex logic** ‚Äî Add comments explaining business rules\n",
  "packages/fetch/validation.md": "# Validation\n\n`@zap-studio/fetch` uses [Standard Schema](https://standardschema.dev/) for runtime validation, which means it works with any schema library that implements the Standard Schema specification.\n\n## Why Validation Matters\n\nAPIs change. Without runtime validation, you might get data that doesn't match your TypeScript types, causing subtle bugs that are hard to track down:\n\n```typescript\n// Without validation\nconst user = await fetch(\"/api/users/1\").then((r) => r.json()) as User;\n// What if the API returns { id: \"123\" } instead of { id: 123 }?\n// TypeScript thinks id is a number, but it's actually a string!\nuser.id + 1; // \"1231\" instead of 124 üò±\n```\n\nWith `@zap-studio/fetch`, you get runtime validation that catches these issues immediately:\n\n```typescript\n// With validation\nconst user = await api.get(\"/api/users/1\", UserSchema);\n// If the API returns { id: \"123\" }, you get a ValidationError\n// instead of silent type mismatch\n```\n\n## Supported Schema Libraries\n\nAny library implementing Standard Schema v1 is supported:\n\n- [Zod](https://zod.dev/) ‚Äî The most popular TypeScript-first schema library\n- [Valibot](https://valibot.dev/) ‚Äî Smaller bundle size alternative\n- [ArkType](https://arktype.io/) ‚Äî 1:1 TypeScript syntax\n- [TypeBox](https://github.com/sinclairzx81/typebox) ‚Äî JSON Schema compatible\n- And more...\n\n## Using Different Schema Libraries\n\n### Zod\n\n```typescript\nimport { z } from \"zod\";\nimport { api } from \"@zap-studio/fetch\";\n\nconst UserSchema = z.object({\n  id: z.number(),\n  name: z.string(),\n  email: z.string().email(),\n  createdAt: z.string().datetime(),\n});\n\nconst user = await api.get(\"/users/1\", UserSchema);\n```\n\n### Valibot\n\n```typescript\nimport * as v from \"valibot\";\nimport { api } from \"@zap-studio/fetch\";\n\nconst UserSchema = v.object({\n  id: v.number(),\n  name: v.string(),\n  email: v.pipe(v.string(), v.email()),\n  createdAt: v.pipe(v.string(), v.isoTimestamp()),\n});\n\nconst user = await api.get(\"/users/1\", UserSchema);\n```\n\n### ArkType\n\n```typescript\nimport { type } from \"arktype\";\nimport { api } from \"@zap-studio/fetch\";\n\nconst UserSchema = type({\n  id: \"number\",\n  name: \"string\",\n  email: \"email\",\n  createdAt: \"string\",\n});\n\nconst user = await api.get(\"/users/1\", UserSchema);\n```\n\n## The standardValidate Helper\n\nFor standalone validation needs, use the `standardValidate` helper:\n\n```typescript\nimport { standardValidate } from \"@zap-studio/fetch/validator\";\nimport { z } from \"zod\";\n\nconst UserSchema = z.object({\n  id: z.number(),\n  name: z.string(),\n});\n\n// Throwing validation (default)\nconst user = await standardValidate(UserSchema, data, true);\n// Returns validated data or throws ValidationError\n\n// Non-throwing validation\nconst result = await standardValidate(UserSchema, data, false);\n// Returns { value: T } or { issues: Issue[] }\n\nif (result.issues) {\n  console.error(\"Validation failed:\", result.issues);\n} else {\n  console.log(\"Valid user:\", result.value);\n}\n```\n\n## isStandardSchema Type Guard\n\nCheck if a value is a Standard Schema:\n\n```typescript\nimport { isStandardSchema } from \"@zap-studio/fetch/validator\";\n\nconst schema = z.object({ name: z.string() });\n\nif (isStandardSchema(schema)) {\n  // TypeScript knows schema is StandardSchemaV1\n  const result = schema[\"~standard\"].validate(data);\n}\n```\n\n## Validation Flow\n\nWhen you pass a schema to `$fetch` or `api.*` methods:\n\n1. The HTTP request is made\n2. The response JSON is parsed\n3. The data is validated against your schema\n4. If valid, the typed data is returned\n5. If invalid and `throwOnValidationError: true`, a `ValidationError` is thrown\n6. If invalid and `throwOnValidationError: false`, a Result object is returned\n\n```typescript\n// Simplified internal flow\nconst response = await fetch(url, options);\nconst rawData = await response.json();\nconst validatedData = await standardValidate(schema, rawData, throwOnValidationError);\nreturn validatedData;\n```\n\n## Handling Validation Results\n\n### Throwing Mode (Default)\n\n```typescript\nimport { ValidationError } from \"@zap-studio/fetch/errors\";\n\ntry {\n  const user = await api.get(\"/users/1\", UserSchema);\n  // user is fully typed: { id: number; name: string; email: string; }\n} catch (error) {\n  if (error instanceof ValidationError) {\n    // Handle validation errors\n    for (const issue of error.issues) {\n      console.error(`${issue.path?.join(\".\")}: ${issue.message}`);\n    }\n  }\n}\n```\n\n### Non-Throwing Mode\n\n```typescript\nconst result = await api.get(\"/users/1\", UserSchema, {\n  throwOnValidationError: false,\n});\n\nif (result.issues) {\n  // Handle validation failure\n  result.issues.forEach((issue) => {\n    console.error(`${issue.path?.join(\".\")}: ${issue.message}`);\n  });\n} else {\n  // Use validated data\n  console.log(\"User name:\", result.value.name);\n}\n```\n\n## Type Inference\n\nTypes are automatically inferred from your schema:\n\n```typescript\nconst UserSchema = z.object({\n  id: z.number(),\n  name: z.string(),\n  email: z.string().email(),\n  roles: z.array(z.enum([\"admin\", \"user\"])),\n});\n\nconst user = await api.get(\"/users/1\", UserSchema);\n// TypeScript infers:\n// {\n//   id: number;\n//   name: string;\n//   email: string;\n//   roles: (\"admin\" | \"user\")[];\n// }\n```\n\n## Best Practices\n\n### 1. Define Schemas Once, Reuse Everywhere\n\n```typescript\n// schemas/user.ts\nimport { z } from \"zod\";\n\nexport const UserSchema = z.object({\n  id: z.number(),\n  name: z.string(),\n  email: z.string().email(),\n  createdAt: z.string().transform((s) => new Date(s)),\n});\n\nexport type User = z.infer<typeof UserSchema>;\n\n// api/users.ts\nimport { api } from \"@zap-studio/fetch\";\nimport { UserSchema, type User } from \"@/schemas/user\";\n\nexport async function getUser(id: number): Promise<User> {\n  return api.get(`/users/${id}`, UserSchema);\n}\n```\n\n### 2. Use Strict Schemas\n\nValidate exactly what you expect:\n\n```typescript\n// Too loose - accepts any extra fields\nconst LooseSchema = z.object({ id: z.number() });\n\n// Better - rejects unknown fields\nconst StrictSchema = z.object({ id: z.number() }).strict();\n```\n\n### 3. Handle Validation Errors Gracefully\n\nAPIs can change unexpectedly:\n\n```typescript\nasync function getUser(id: string) {\n  try {\n    return await api.get(`/users/${id}`, UserSchema);\n  } catch (error) {\n    if (error instanceof ValidationError) {\n      // Log for debugging but don't crash\n      console.error(\"API response changed:\", error.issues);\n      // Return partial data or fallback\n      return null;\n    }\n    throw error;\n  }\n}\n```\n\n### 4. Use Schema Transforms\n\nParse and transform data in your schema:\n\n```typescript\nconst DateSchema = z.string().transform((s) => new Date(s));\n\nconst PriceSchema = z.number().transform((cents) => ({\n  cents,\n  dollars: cents / 100,\n  formatted: `$${(cents / 100).toFixed(2)}`,\n}));\n```\n\n### 5. Compose Schemas\n\nBuild complex schemas from simpler parts:\n\n```typescript\nconst AddressSchema = z.object({\n  street: z.string(),\n  city: z.string(),\n  country: z.string(),\n});\n\nconst UserSchema = z.object({\n  id: z.string(),\n  name: z.string(),\n  address: AddressSchema.optional(),\n});\n\nconst OrderSchema = z.object({\n  id: z.string(),\n  user: UserSchema,\n  shippingAddress: AddressSchema,\n  billingAddress: AddressSchema.optional(),\n});\n```\n",
  "packages/fetch/index.md": "# @zap-studio/fetch\n\nA type-safe fetch wrapper with Standard Schema validation.\n\n## Why @zap-studio/fetch?\n\nWhen fetching data from APIs, TypeScript can't verify that the response matches your expected type. You end up with unsafe type assertions that can cause runtime errors.\n\n**Before:**\n\n```typescript\nconst response = await fetch(\"/api/users/1\");\nconst data = await response.json();\nconst user = data as User; // üò± Unsafe type assertion\n// If the API returns { name: \"John\" } instead of { id: 1, name: \"John\" },\n// your app breaks at runtime with no warning\n```\n\n**After:**\n\n```typescript\nimport { api } from \"@zap-studio/fetch\";\n\nconst user = await api.get(\"/api/users/1\", UserSchema);\n// ‚ú® Typed, validated, and safe!\n// If the API response doesn't match UserSchema, you get a clear error\n```\n\n## Features\n\n- **Type-safe requests** with automatic type inference\n- **Runtime validation** using Standard Schema (Zod, Valibot, ArkType, etc.)\n- **Convenient API methods** (GET, POST, PUT, PATCH, DELETE)\n- **Factory pattern** for creating pre-configured instances with base URLs\n- **Custom error handling** with FetchError and ValidationError classes\n- **Full TypeScript support** with zero configuration\n\n## Installation\n\n```bash\npnpm add @zap-studio/fetch\n# or\nnpm install @zap-studio/fetch\n```\n\n## Quick Start\n\nLet's build a type-safe API client for a user management system.\n\n### 1. Define Your Schema\n\nFirst, define the shape of your API responses using any Standard Schema library:\n\n```typescript\nimport { z } from \"zod\";\n\n// Define the user schema\nconst UserSchema = z.object({\n  id: z.number(),\n  name: z.string(),\n  email: z.string().email(),\n  role: z.enum([\"admin\", \"user\", \"guest\"]),\n  createdAt: z.string().transform((s) => new Date(s)),\n});\n\ntype User = z.infer<typeof UserSchema>;\n```\n\n### 2. Make Type-Safe Requests\n\n```typescript\nimport { api } from \"@zap-studio/fetch\";\n\n// Fetch a single user - fully typed and validated\nconst user = await api.get(\"https://api.example.com/users/1\", UserSchema);\n\nconsole.log(user.name);      // TypeScript knows this is a string\nconsole.log(user.createdAt); // TypeScript knows this is a Date\n```\n\n### 3. Handle Errors Gracefully\n\n```typescript\nimport { FetchError, ValidationError } from \"@zap-studio/fetch/errors\";\n\ntry {\n  const user = await api.get(\"https://api.example.com/users/1\", UserSchema);\n  console.log(`Hello, ${user.name}!`);\n} catch (error) {\n  if (error instanceof FetchError) {\n    // HTTP error (404, 500, etc.)\n    console.error(`API error: ${error.status}`);\n  } else if (error instanceof ValidationError) {\n    // Response didn't match schema\n    console.error(\"Invalid API response:\", error.issues);\n  }\n}\n```\n\n## What's Next?\n\n- [API Methods](/packages/fetch/api-methods) ‚Äî Learn about GET, POST, PUT, PATCH, DELETE\n- [Using $fetch](/packages/fetch/fetch-function) ‚Äî Direct fetch usage with and without validation\n- [Factory Pattern](/packages/fetch/create-fetch) ‚Äî Create pre-configured instances\n- [Error Handling](/packages/fetch/errors) ‚Äî Handle HTTP and validation errors\n- [Validation](/packages/fetch/validation) ‚Äî Deep dive into schema validation\n",
  "packages/fetch/fetch-function.md": "# Using $fetch\n\nThe `$fetch` function provides more control over your requests. You can use it with or without schema validation, making it flexible for different use cases.\n\n## When to Use $fetch\n\nUse `$fetch` instead of `api.*` methods when you need:\n\n- Raw `Response` objects for headers, status codes, or streaming\n- Non-JSON responses (binary files, text, HTML)\n- Conditional validation based on response status\n- More control over the request/response cycle\n\n## With Schema Validation\n\nWhen you pass a schema, `$fetch` validates the response and returns typed data:\n\n```typescript\nimport { z } from \"zod\";\nimport { $fetch } from \"@zap-studio/fetch\";\n\nconst UserSchema = z.object({\n  id: z.number(),\n  name: z.string(),\n  email: z.string().email(),\n});\n\nconst user = await $fetch(\"https://api.example.com/users/1\", UserSchema, {\n  headers: {\n    Authorization: \"Bearer token\",\n  },\n});\n\n// user is typed as { id: number; name: string; email: string }\nconsole.log(user.name);\n```\n\n## Without Schema Validation\n\nWhen you don't pass a schema, `$fetch` returns the raw `Response` object:\n\n```typescript\nimport { $fetch } from \"@zap-studio/fetch\";\n\nconst response = await $fetch(\"https://api.example.com/users/1\");\n\n// response is a standard Response object\nconsole.log(response.status);      // 200\nconsole.log(response.headers);     // Headers object\nconst data = await response.json(); // Manual parsing\n```\n\n## Function Signatures\n\n`$fetch` has two overloaded signatures:\n\n```typescript\n// With schema - returns validated data\nasync function $fetch<TSchema extends StandardSchemaV1>(\n  resource: string,\n  schema: TSchema,\n  options?: ExtendedRequestInit\n): Promise<StandardSchemaV1.InferOutput<TSchema>>;\n\n// Without schema - returns raw Response\nasync function $fetch(\n  resource: string,\n  options?: ExtendedRequestInit\n): Promise<Response>;\n```\n\n## Extended Request Options\n\n| Option | Type | Default | Description |\n| ------ | ---- | ------- | ----------- |\n| `body` | `BodyInit \\| Record<string, unknown>` | - | Request body (auto-stringified when schema is present) |\n| `searchParams` | `URLSearchParams \\| Record<string, string>` | - | Query parameters |\n| `throwOnFetchError` | `boolean` | `true` | Throw `FetchError` on non-2xx responses |\n| `throwOnValidationError` | `boolean` | `true` | Throw `ValidationError` on schema validation failures |\n\nPlus all standard [RequestInit](https://developer.mozilla.org/en-US/docs/Web/API/RequestInit) options.\n\n## Examples\n\n### POST with JSON body\n\n```typescript\nconst user = await $fetch(\"https://api.example.com/users\", UserSchema, {\n  method: \"POST\",\n  body: {\n    name: \"John Doe\",\n    email: \"john@example.com\",\n  },\n});\n```\n\n### GET with query parameters\n\n```typescript\nconst url = new URL(\"https://api.example.com/users\");\nurl.searchParams.set(\"page\", \"1\");\nurl.searchParams.set(\"limit\", \"10\");\n\nconst users = await $fetch(url.toString(), UsersSchema);\n```\n\n### Handling non-JSON responses\n\n```typescript\nconst response = await $fetch(\"https://api.example.com/file.pdf\");\n\nif (response.ok) {\n  const blob = await response.blob();\n  // Handle the binary data\n}\n```\n\n### Custom headers\n\n```typescript\nconst user = await $fetch(\"https://api.example.com/users/1\", UserSchema, {\n  headers: {\n    Authorization: \"Bearer token\",\n    \"Accept-Language\": \"en-US\",\n    \"X-Request-ID\": crypto.randomUUID(),\n  },\n});\n```\n",
  "packages/fetch/errors.md": "# Error Handling\n\n`@zap-studio/fetch` provides two specialized error classes for granular error handling: `FetchError` for HTTP errors and `ValidationError` for schema validation failures.\n\n## Why Custom Error Classes?\n\nWhen fetching data, many things can go wrong:\n\n- **Network errors** ‚Äî Connection failed, timeout, DNS issues\n- **HTTP errors** ‚Äî 404 Not Found, 401 Unauthorized, 500 Server Error\n- **Validation errors** ‚Äî API returned data that doesn't match your schema\n\nCustom error classes let you handle each case appropriately:\n\n```typescript\ntry {\n  const user = await api.get(\"/users/1\", UserSchema);\n} catch (error) {\n  if (error instanceof FetchError) {\n    // HTTP error - check status code\n  } else if (error instanceof ValidationError) {\n    // Data doesn't match schema\n  } else {\n    // Network or other error\n  }\n}\n```\n\n## Importing Error Classes\n\n```typescript\nimport { FetchError, ValidationError } from \"@zap-studio/fetch/errors\";\n```\n\n## FetchError\n\nThrown when the HTTP response status is not ok (non-2xx status codes) and `throwOnFetchError` is `true` (default).\n\n### Properties\n\n| Property | Type | Description |\n| -------- | ---- | ----------- |\n| `name` | `string` | Always `\"FetchError\"` |\n| `message` | `string` | Error message with status info |\n| `status` | `number` | HTTP status code |\n| `response` | `Response` | The full Response object |\n\n### Basic Example\n\n```typescript\nimport { api } from \"@zap-studio/fetch\";\nimport { FetchError } from \"@zap-studio/fetch/errors\";\n\ntry {\n  const user = await api.get(\"/api/users/999\", UserSchema);\n} catch (error) {\n  if (error instanceof FetchError) {\n    console.error(`HTTP Error ${error.status}: ${error.message}`);\n\n    // Access the full response\n    const body = await error.response.text();\n    console.error(\"Response body:\", body);\n\n    // Handle specific status codes\n    if (error.status === 404) {\n      console.log(\"User not found\");\n    } else if (error.status === 401) {\n      console.log(\"Unauthorized - please log in\");\n    }\n  }\n}\n```\n\n## ValidationError\n\nThrown when schema validation fails and `throwOnValidationError` is `true` (default).\n\n### Properties\n\n| Property | Type | Description |\n| -------- | ---- | ----------- |\n| `name` | `string` | Always `\"ValidationError\"` |\n| `message` | `string` | JSON-formatted validation issues |\n| `issues` | `StandardSchemaV1.Issue[]` | Array of validation issues |\n\n### Issue Structure\n\nEach issue follows the Standard Schema format:\n\n```typescript\ninterface Issue {\n  message: string;      // Human-readable error message\n  path?: PropertyKey[]; // Path to the invalid field\n}\n```\n\n### Basic Example\n\n```typescript\nimport { api } from \"@zap-studio/fetch\";\nimport { ValidationError } from \"@zap-studio/fetch/errors\";\n\ntry {\n  const user = await api.get(\"/api/users/1\", UserSchema);\n} catch (error) {\n  if (error instanceof ValidationError) {\n    console.error(\"Validation failed!\");\n\n    for (const issue of error.issues) {\n      const path = issue.path?.join(\".\") || \"root\";\n      console.error(`  - ${path}: ${issue.message}`);\n    }\n  }\n}\n```\n\n## Combined Error Handling\n\nHandle both error types in a single try-catch:\n\n```typescript\nimport { z } from \"zod\";\nimport { api } from \"@zap-studio/fetch\";\nimport { FetchError, ValidationError } from \"@zap-studio/fetch/errors\";\n\nconst UserSchema = z.object({\n  id: z.string(),\n  name: z.string(),\n  email: z.string().email(),\n});\n\ntype FetchResult<T> =\n  | { success: true; data: T }\n  | { success: false; error: string; code: string };\n\nasync function safeGetUser(id: string): Promise<FetchResult<z.infer<typeof UserSchema>>> {\n  try {\n    const data = await api.get(`/api/users/${id}`, UserSchema);\n    return { success: true, data };\n  } catch (error) {\n    if (error instanceof FetchError) {\n      if (error.status === 404) {\n        return { success: false, error: \"User not found\", code: \"NOT_FOUND\" };\n      }\n      if (error.status === 401) {\n        return { success: false, error: \"Please log in\", code: \"UNAUTHORIZED\" };\n      }\n      return { success: false, error: `Server error: ${error.status}`, code: \"SERVER_ERROR\" };\n    }\n\n    if (error instanceof ValidationError) {\n      return {\n        success: false,\n        error: \"Invalid data received from server\",\n        code: \"VALIDATION_ERROR\",\n      };\n    }\n\n    return { success: false, error: \"Network error\", code: \"NETWORK_ERROR\" };\n  }\n}\n\n// Usage\nconst result = await safeGetUser(\"123\");\n\nif (result.success) {\n  console.log(`Hello, ${result.data.name}!`);\n} else {\n  console.error(`[${result.code}] ${result.error}`);\n}\n```\n\n## Disabling Error Throwing\n\nYou can disable automatic error throwing to handle errors manually.\n\n### Disabling FetchError\n\n```typescript\nconst response = await $fetch(\"/api/users/999\", {\n  throwOnFetchError: false,\n});\n\n// Check status manually\nif (!response.ok) {\n  console.log(\"Request failed:\", response.status);\n}\n```\n\n### Disabling ValidationError\n\nWhen disabled, validation returns a Result object instead of throwing:\n\n```typescript\nconst result = await $fetch(\"/api/users/1\", UserSchema, {\n  throwOnValidationError: false,\n});\n\nif (result.issues) {\n  // Validation failed\n  console.error(\"Validation issues:\", result.issues);\n} else {\n  // Validation succeeded\n  console.log(\"User:\", result.value);\n}\n```\n\n### Result Type\n\nWhen `throwOnValidationError` is `false`, the return type is a Standard Schema Result:\n\n```typescript\ntype Result<T> =\n  | { value: T; issues?: undefined }\n  | { value?: undefined; issues: Issue[] };\n```\n\n## Best Practices\n\n1. **Always handle both error types** when making API calls\n2. **Use specific error handlers** for different status codes\n3. **Log validation issues** to help debug API response changes\n4. **Consider disabling throws** for expected error cases (like 404s)\n5. **Re-throw unexpected errors** to avoid silently swallowing issues\n6. **Parse error responses** to get structured error information from APIs\n",
  "packages/fetch/create-fetch.md": "# Factory Pattern with createFetch\n\nThe `createFetch` function allows you to create pre-configured fetch instances with base URLs and default headers. This is ideal for building API clients that need consistent configuration across requests.\n\n## Why Use createFetch?\n\nWhen building applications, you often make requests to the same API with the same headers (authentication, content type, etc.). Instead of repeating this configuration:\n\n```typescript\n// Without createFetch - repetitive\nconst user = await $fetch(\"https://api.example.com/users/1\", UserSchema, {\n  headers: { Authorization: \"Bearer token\", \"X-API-Key\": \"key\" },\n});\n\nconst posts = await $fetch(\"https://api.example.com/posts\", PostsSchema, {\n  headers: { Authorization: \"Bearer token\", \"X-API-Key\": \"key\" },\n});\n```\n\nYou can configure once and reuse:\n\n```typescript\n// With createFetch - clean and DRY\nconst { api } = createFetch({\n  baseURL: \"https://api.example.com\",\n  headers: { Authorization: \"Bearer token\", \"X-API-Key\": \"key\" },\n});\n\nconst user = await api.get(\"/users/1\", UserSchema);\nconst posts = await api.get(\"/posts\", PostsSchema);\n```\n\n## Basic Usage\n\n```typescript\nimport { z } from \"zod\";\nimport { createFetch } from \"@zap-studio/fetch\";\n\nconst { $fetch, api } = createFetch({\n  baseURL: \"https://api.example.com\",\n  headers: {\n    Authorization: \"Bearer your-token\",\n    \"X-API-Key\": \"your-api-key\",\n  },\n});\n\nconst UserSchema = z.object({\n  id: z.number(),\n  name: z.string(),\n});\n\n// Use relative paths - baseURL is prepended automatically\nconst user = await api.get(\"/users/1\", UserSchema);\n\n// POST with auto-stringified body\nconst newUser = await api.post(\"/users\", UserSchema, {\n  body: { name: \"John Doe\" },\n});\n```\n\n## Factory Options\n\n| Option | Type | Default | Description |\n| ------ | ---- | ------- | ----------- |\n| `baseURL` | `string` | `\"\"` | Base URL prepended to relative paths only |\n| `headers` | `HeadersInit` | - | Default headers included in all requests |\n| `searchParams` | `URLSearchParams \\| Record<string, string>` | - | Default query params included in all requests |\n| `throwOnFetchError` | `boolean` | `true` | Throw `FetchError` on non-2xx responses |\n| `throwOnValidationError` | `boolean` | `true` | Throw `ValidationError` on schema validation failures |\n\n## URL Handling\n\n### Relative URLs\n\nRelative URLs are automatically prefixed with the `baseURL`:\n\n```typescript\nconst { api } = createFetch({ baseURL: \"https://api.example.com\" });\n\n// Fetches https://api.example.com/users\nconst users = await api.get(\"/users\", UsersSchema);\n\n// Leading slash is optional\nconst user = await api.get(\"users/1\", UserSchema);\n```\n\n### Absolute URLs\n\nAbsolute URLs (starting with `http://`, `https://`, or `//`) ignore the `baseURL`:\n\n```typescript\nconst { api } = createFetch({ baseURL: \"https://api.example.com\" });\n\n// Fetches https://other-api.com/data (ignores baseURL)\nconst data = await api.get(\"https://other-api.com/data\", DataSchema);\n```\n\n## Header Merging\n\nDefault headers from the factory are merged with per-request headers. Per-request headers take precedence:\n\n```typescript\nconst { api } = createFetch({\n  baseURL: \"https://api.example.com\",\n  headers: {\n    Authorization: \"Bearer default-token\",\n    \"Content-Type\": \"application/json\",\n  },\n});\n\n// This request will have:\n// - Authorization: Bearer override-token (overridden)\n// - Content-Type: application/json (from defaults)\n// - X-Custom: value (new header)\nconst user = await api.get(\"/users/1\", UserSchema, {\n  headers: {\n    Authorization: \"Bearer override-token\",\n    \"X-Custom\": \"value\",\n  },\n});\n```\n\n## Search Params Merging\n\nDefault search params are merged with per-request and URL params:\n\n```typescript\nconst { api } = createFetch({\n  baseURL: \"https://api.example.com\",\n  searchParams: { locale: \"en\", page: \"1\" },\n});\n\n// Final URL: /users?locale=en&page=2&q=alex\n// - locale: en (from defaults)\n// - page: 2 (overridden by per-request)\n// - q: alex (new param)\nconst user = await api.get(\"/users\", UserSchema, {\n  searchParams: { page: \"2\", q: \"alex\" },\n});\n```\n\nPriority order:\n1. **Factory defaults** ‚Äî lowest priority\n2. **URL params** ‚Äî override factory defaults\n3. **Per-request params** ‚Äî highest priority\n\n## Real-World Examples\n\n### Multiple API Clients\n\nCreate separate clients for different APIs in your application:\n\n```typescript\nimport { z } from \"zod\";\nimport { createFetch } from \"@zap-studio/fetch\";\n\n// GitHub API client\nconst github = createFetch({\n  baseURL: \"https://api.github.com\",\n  headers: {\n    Authorization: `token ${process.env.GITHUB_TOKEN}`,\n    Accept: \"application/vnd.github.v3+json\",\n  },\n});\n\n// Stripe API client\nconst stripe = createFetch({\n  baseURL: \"https://api.stripe.com/v1\",\n  headers: {\n    Authorization: `Bearer ${process.env.STRIPE_SECRET_KEY}`,\n  },\n});\n\n// Internal API client\nconst internal = createFetch({\n  baseURL: process.env.API_URL,\n  headers: {\n    \"X-Internal-Key\": process.env.INTERNAL_API_KEY,\n  },\n});\n\n// Schemas\nconst RepoSchema = z.object({\n  id: z.number(),\n  name: z.string(),\n  full_name: z.string(),\n  private: z.boolean(),\n});\n\nconst CustomerSchema = z.object({\n  id: z.string(),\n  email: z.string(),\n  name: z.string().nullable(),\n});\n\n// Usage\nconst repo = await github.api.get(\"/repos/owner/repo\", RepoSchema);\nconst customer = await stripe.api.get(\"/customers/cus_123\", CustomerSchema);\n```\n\n## Configuring Error Behavior\n\nYou can configure default error throwing behavior at the factory level:\n\n```typescript\n// Never throw validation errors by default\nconst { api } = createFetch({\n  baseURL: \"https://api.example.com\",\n  throwOnValidationError: false,\n});\n\n// All requests return Result objects instead of throwing\nconst result = await api.get(\"/users/1\", UserSchema);\n\nif (result.issues) {\n  console.error(\"Validation failed:\", result.issues);\n} else {\n  console.log(\"Success:\", result.value);\n}\n```\n\nYou can still override this per-request:\n\n```typescript\n// Override to throw for this specific request\nconst user = await api.get(\"/users/1\", UserSchema, {\n  throwOnValidationError: true,\n});\n```\n\n## Return Type\n\n`createFetch` returns an object with both `$fetch` and `api`:\n\n```typescript\nconst { $fetch, api } = createFetch({\n  baseURL: \"https://api.example.com\",\n});\n\n// Use api.* for convenience methods\nconst user = await api.get(\"/users/1\", UserSchema);\n\n// Use $fetch for raw responses or more control\nconst response = await $fetch(\"/health\");\nconsole.log(\"Status:\", response.status);\n```\n",
  "packages/fetch/api-methods.md": "# API Methods\n\nThe `api` object provides convenient methods for common HTTP verbs. All methods require a schema for validation and return fully typed, validated data.\n\n## Overview\n\nThe `api` object includes methods for the five most common HTTP verbs:\n\n| Method | Use Case |\n| ------ | -------- |\n| `api.get()` | Retrieve data (users, products, etc.) |\n| `api.post()` | Create new resources |\n| `api.put()` | Replace entire resources |\n| `api.patch()` | Partially update resources |\n| `api.delete()` | Remove resources |\n\nAll methods automatically:\n- Set `Content-Type: application/json` for request bodies\n- JSON-stringify objects passed as `body`\n- Validate responses against your schema\n- Provide full TypeScript type inference\n\n## api.get()\n\nRetrieves data from the server. Use for fetching resources.\n\n```typescript\napi.get(url, schema, options?)\n```\n\n### Example: Fetching a User Profile\n\n```typescript\nimport { z } from \"zod\";\nimport { api } from \"@zap-studio/fetch\";\n\nconst UserProfileSchema = z.object({\n  id: z.string(),\n  name: z.string(),\n  email: z.string().email(),\n  avatar: z.string().url().nullable(),\n  bio: z.string().optional(),\n  joinedAt: z.string(),\n});\n\nasync function getUserProfile(userId: string) {\n  const profile = await api.get(\n    `https://api.example.com/users/${userId}`,\n    UserProfileSchema\n  );\n\n  return profile;\n  // Type: { id: string; name: string; email: string; avatar: string | null; bio?: string; joinedAt: string }\n}\n```\n\n### Example: Fetching with Query Parameters\n\n```typescript\nconst ProductListSchema = z.object({\n  products: z.array(\n    z.object({\n      id: z.string(),\n      name: z.string(),\n      price: z.number(),\n    })\n  ),\n  total: z.number(),\n  page: z.number(),\n  perPage: z.number(),\n});\n\nasync function searchProducts(query: string, page = 1) {\n  const url = new URL(\"https://api.example.com/products\");\n  url.searchParams.set(\"q\", query);\n  url.searchParams.set(\"page\", String(page));\n  url.searchParams.set(\"limit\", \"20\");\n\n  return api.get(url.toString(), ProductListSchema);\n}\n\n// Usage\nconst results = await searchProducts(\"laptop\", 2);\nconsole.log(`Found ${results.total} products`);\n```\n\n## api.post()\n\nCreates new resources on the server. The request body is automatically JSON-stringified.\n\n```typescript\napi.post(url, schema, options?)\n```\n\n### Example: Creating a New User\n\n```typescript\nconst CreateUserResponseSchema = z.object({\n  id: z.string(),\n  name: z.string(),\n  email: z.string().email(),\n  createdAt: z.string(),\n});\n\nasync function createUser(name: string, email: string, password: string) {\n  const user = await api.post(\n    \"https://api.example.com/users\",\n    CreateUserResponseSchema,\n    {\n      body: {\n        name,\n        email,\n        password,\n      },\n    }\n  );\n\n  console.log(`User ${user.id} created at ${user.createdAt}`);\n  return user;\n}\n```\n\n### Example: Submitting a Form\n\n```typescript\nconst SubmissionSchema = z.object({\n  id: z.string(),\n  status: z.enum([\"pending\", \"approved\", \"rejected\"]),\n  submittedAt: z.string(),\n});\n\nasync function submitContactForm(data: {\n  name: string;\n  email: string;\n  message: string;\n}) {\n  return api.post(\"https://api.example.com/contact\", SubmissionSchema, {\n    body: data,\n  });\n}\n\n// Usage\nconst submission = await submitContactForm({\n  name: \"Jane Doe\",\n  email: \"jane@example.com\",\n  message: \"Hello! I have a question about your product.\",\n});\n\nif (submission.status === \"pending\") {\n  console.log(\"Your message has been received!\");\n}\n```\n\n## api.put()\n\nReplaces an entire resource. Use when you want to update all fields.\n\n```typescript\napi.put(url, schema, options?)\n```\n\n### Example: Updating User Settings\n\n```typescript\nconst UserSettingsSchema = z.object({\n  userId: z.string(),\n  theme: z.enum([\"light\", \"dark\", \"system\"]),\n  language: z.string(),\n  notifications: z.object({\n    email: z.boolean(),\n    push: z.boolean(),\n    sms: z.boolean(),\n  }),\n  updatedAt: z.string(),\n});\n\ntype UserSettings = z.infer<typeof UserSettingsSchema>;\n\nasync function updateSettings(userId: string, settings: Omit<UserSettings, \"userId\" | \"updatedAt\">) {\n  return api.put(\n    `https://api.example.com/users/${userId}/settings`,\n    UserSettingsSchema,\n    {\n      body: settings,\n    }\n  );\n}\n\n// Usage: replaces ALL settings\nconst updated = await updateSettings(\"user-123\", {\n  theme: \"dark\",\n  language: \"en-US\",\n  notifications: {\n    email: true,\n    push: true,\n    sms: false,\n  },\n});\n```\n\n## api.patch()\n\nPartially updates a resource. Use when you only want to change specific fields.\n\n```typescript\napi.patch(url, schema, options?)\n```\n\n### Example: Updating Profile Fields\n\n```typescript\nconst ProfileSchema = z.object({\n  id: z.string(),\n  name: z.string(),\n  bio: z.string().nullable(),\n  website: z.string().url().nullable(),\n  updatedAt: z.string(),\n});\n\nasync function updateProfile(\n  userId: string,\n  updates: Partial<{ name: string; bio: string; website: string }>\n) {\n  return api.patch(\n    `https://api.example.com/users/${userId}/profile`,\n    ProfileSchema,\n    {\n      body: updates,\n    }\n  );\n}\n\n// Usage: only updates the bio field\nconst profile = await updateProfile(\"user-123\", {\n  bio: \"Software engineer passionate about TypeScript\",\n});\n```\n\n### Example: Toggling a Feature\n\n```typescript\nconst FeatureToggleSchema = z.object({\n  feature: z.string(),\n  enabled: z.boolean(),\n  updatedAt: z.string(),\n});\n\nasync function toggleFeature(userId: string, feature: string, enabled: boolean) {\n  return api.patch(\n    `https://api.example.com/users/${userId}/features/${feature}`,\n    FeatureToggleSchema,\n    {\n      body: { enabled },\n    }\n  );\n}\n```\n\n## api.delete()\n\nRemoves a resource from the server.\n\n```typescript\napi.delete(url, schema, options?)\n```\n\n### Example: Deleting a Post\n\n```typescript\nconst DeleteResponseSchema = z.object({\n  success: z.boolean(),\n  deletedAt: z.string(),\n});\n\nasync function deletePost(postId: string) {\n  const result = await api.delete(\n    `https://api.example.com/posts/${postId}`,\n    DeleteResponseSchema\n  );\n\n  if (result.success) {\n    console.log(`Post deleted at ${result.deletedAt}`);\n  }\n\n  return result;\n}\n```\n\n### Example: Removing from Cart\n\n```typescript\nconst CartSchema = z.object({\n  id: z.string(),\n  items: z.array(\n    z.object({\n      productId: z.string(),\n      quantity: z.number(),\n    })\n  ),\n  total: z.number(),\n});\n\nasync function removeFromCart(cartId: string, productId: string) {\n  // Returns the updated cart\n  return api.delete(\n    `https://api.example.com/carts/${cartId}/items/${productId}`,\n    CartSchema\n  );\n}\n```\n\n## Request Options\n\nAll methods accept an optional `options` parameter:\n\n| Option | Type | Default | Description |\n| ------ | ---- | ------- | ----------- |\n| `body` | `object \\| BodyInit` | - | Request body (auto-stringified for objects) |\n| `headers` | `HeadersInit` | - | Additional request headers |\n| `searchParams` | `URLSearchParams \\| Record<string, string>` | - | Query parameters |\n| `throwOnFetchError` | `boolean` | `true` | Throw `FetchError` on non-2xx responses |\n| `throwOnValidationError` | `boolean` | `true` | Throw `ValidationError` on schema failures |\n\nPlus all standard [RequestInit](https://developer.mozilla.org/en-US/docs/Web/API/RequestInit) options.\n\n## Real-World Example: Blog API Client\n\n```typescript\nimport { z } from \"zod\";\nimport { createFetch } from \"@zap-studio/fetch\";\n\n// Schemas\nconst PostSchema = z.object({\n  id: z.string(),\n  title: z.string(),\n  content: z.string(),\n  authorId: z.string(),\n  published: z.boolean(),\n  createdAt: z.string(),\n  updatedAt: z.string(),\n});\n\nconst PostListSchema = z.object({\n  posts: z.array(PostSchema),\n  total: z.number(),\n  hasMore: z.boolean(),\n});\n\nconst CommentSchema = z.object({\n  id: z.string(),\n  postId: z.string(),\n  authorId: z.string(),\n  content: z.string(),\n  createdAt: z.string(),\n});\n\n// Create API client\nconst { api } = createFetch({\n  baseURL: \"https://api.myblog.com/v1\",\n  headers: {\n    Authorization: `Bearer ${getAuthToken()}`,\n  },\n});\n\n// Blog API functions\nexport const blogApi = {\n  // Get all posts\n  async getPosts(page = 1, limit = 10) {\n    return api.get(\"/posts\", PostListSchema, {\n      searchParams: { page: String(page), limit: String(limit) },\n    });\n  },\n\n  // Get single post\n  async getPost(id: string) {\n    return api.get(`/posts/${id}`, PostSchema);\n  },\n\n  // Create post\n  async createPost(data: { title: string; content: string }) {\n    return api.post(\"/posts\", PostSchema, { body: data });\n  },\n\n  // Update post\n  async updatePost(id: string, data: Partial<{ title: string; content: string; published: boolean }>) {\n    return api.patch(`/posts/${id}`, PostSchema, { body: data });\n  },\n\n  // Delete post\n  async deletePost(id: string) {\n    return api.delete(`/posts/${id}`, z.object({ success: z.boolean() }));\n  },\n\n  // Add comment\n  async addComment(postId: string, content: string) {\n    return api.post(`/posts/${postId}/comments`, CommentSchema, {\n      body: { content },\n    });\n  },\n};\n\n// Usage\nconst { posts, hasMore } = await blogApi.getPosts();\nconst newPost = await blogApi.createPost({\n  title: \"My First Post\",\n  content: \"Hello, world!\",\n});\nawait blogApi.updatePost(newPost.id, { published: true });\n```\n\n## Note on Raw Responses\n\nThe `api.*` methods always require a schema for validation. If you need raw responses without validation, use [`$fetch`](/packages/fetch/fetch-function) directly.\n",
  "local-ts/window-state.md": "# Window State\n\nLocal.ts uses the [Tauri window state plugin](https://v2.tauri.app/plugin/window-state/) to automatically remember your window size, position, and state across app restarts.\n\nThis creates a polished desktop experience where users don't have to resize their window every time they open the app.\n\n## What Gets Saved\n\nThe window state plugin tracks:\n\n| Property | Description |\n|----------|-------------|\n| Size | Window width and height |\n| Position | Window X and Y coordinates |\n| Maximized | Whether the window is maximized |\n| Fullscreen | Whether the window is in fullscreen |\n| Decorations | Whether window decorations are visible |\n\n## How It Works\n\n### Initialization\n\nThe plugin is initialized during app setup and restores state for all windows:\n\n```rust\n// src-tauri/src/lib.rs\n.setup(|app| {\n    plugins::logging::init(app);\n\n    // Initialize window state plugin\n    #[cfg(desktop)]\n    plugins::window_state::init(app)?;\n\n    // ... other setup code\n    Ok(())\n})\n```\n\nThe `init` function registers the plugin and restores saved state.\n\n### Saving State\n\nWindow state is saved automatically when the window closes:\n\n```rust\n// src-tauri/src/lib.rs\n.on_window_event(|window, event| {\n    #[cfg(desktop)]\n    if let tauri::WindowEvent::CloseRequested { .. } = event {\n        plugins::window_state::on_close_requested(window);\n    }\n})\n```\n\nThe `on_close_requested` function handles the save operation.\n\n## Customizing What's Saved\n\nYou can choose which properties to persist by modifying the `StateFlags` in the plugin module:\n\n```rust\n// src-tauri/src/plugins/window_state.rs\npub fn init<R: Runtime>(app: &App<R>) -> Result<(), Box<dyn std::error::Error>> {\n    // ... plugin registration ...\n\n    // Only restore size and position\n    let flags = StateFlags::SIZE | StateFlags::POSITION;\n    \n    for (label, window) in windows {\n        if let Err(err) = window.restore_state(flags) {\n            log::warn!(\"Failed to restore state for window '{}': {}\", label, err);\n        }\n    }\n\n    Ok(())\n}\n\npub fn on_close_requested<R: Runtime>(window: &Window<R>) {\n    // Only save size and position\n    let flags = StateFlags::SIZE | StateFlags::POSITION;\n    \n    if let Err(err) = window.app_handle().save_window_state(flags) {\n        log::warn!(\n            \"Failed to save window state for '{}': {}\",\n            window.label(),\n            err\n        );\n    }\n}\n```\n\nAvailable flags:\n\n| Flag | What It Saves |\n|------|---------------|\n| `StateFlags::SIZE` | Window dimensions |\n| `StateFlags::POSITION` | Window location |\n| `StateFlags::MAXIMIZED` | Maximized state |\n| `StateFlags::VISIBLE` | Visibility state |\n| `StateFlags::DECORATIONS` | Window decorations |\n| `StateFlags::FULLSCREEN` | Fullscreen state |\n| `StateFlags::all()` | All of the above |\n\n## Default Window Size\n\nSet default dimensions in `src-tauri/tauri.conf.json` for first launch before any state is saved:\n\n```json\n{\n  \"windows\": [{\n    \"title\": \"Local.ts\",\n    \"label\": \"main\",\n    \"visible\": false,\n    \"width\": 1280,\n    \"height\": 720,\n    \"center\": true\n  }]\n}\n```\n\nThese defaults are used only on first launch.\n\n## Error Handling\n\nThe window state plugin uses proper error handling with logging:\n\n- **Restore failures** are logged as warnings but don't prevent the app from starting\n- **Save failures** are logged as warnings to help debug state persistence issues\n- Window labels are included in error messages for easier troubleshooting\n\nThis ensures that state management issues won't crash your application.\n\n## Saving State Periodically\n\nInstead of (or in addition to) saving on close, you can save state periodically by adding a function to the plugin:\n\n```rust\n// src-tauri/src/plugins/window_state.rs\nuse std::time::Duration;\n\npub fn start_periodic_save<R: Runtime>(app: &App<R>) {\n    let app_handle = app.handle().clone();\n    std::thread::spawn(move || {\n        loop {\n            std::thread::sleep(Duration::from_secs(300)); // 5 minutes\n            if let Err(err) = app_handle.save_window_state(StateFlags::all()) {\n                log::warn!(\"Failed to save window state periodically: {}\", err);\n            }\n        }\n    });\n}\n```\n\nThen call it from your setup:\n\n```rust\n// src-tauri/src/lib.rs\n.setup(|app| {\n    #[cfg(desktop)]\n    {\n        plugins::window_state::init(app)?;\n        plugins::window_state::start_periodic_save(app);\n    }\n    \n    Ok(())\n})\n```\n\nThis protects against state loss if the app crashes.\n\n::: info\nThe spawned thread runs for the application's entire lifetime ‚Äî it will only exit when the application terminates, so make sure any resources accessed from that thread are safe to use for the duration of the process.\n:::\n\n## Removing Window State\n\nIf you don't need window state persistence:\n\n1. **Remove the plugin module** at `src-tauri/src/plugins/window_state.rs`\n\n2. **Remove the initialization** from `src-tauri/src/lib.rs`:\n\n   ```diff\n   - #[cfg(desktop)]\n   - plugins::window_state::init(app)?;\n   ```\n\n3. **Remove the window event handler** from `src-tauri/src/lib.rs`:\n\n   ```diff\n   - .on_window_event(|window, event| {\n   -     #[cfg(desktop)]\n   -     if let tauri::WindowEvent::CloseRequested { .. } = event {\n   -         plugins::window_state::on_close_requested(window);\n   -     }\n   - })\n   ```\n\n4. **Remove the dependency** from `src-tauri/Cargo.toml`:\n\n   ```diff\n   - tauri-plugin-window-state = \"2\"\n   ```\n\n5. **Remove permissions** from `src-tauri/capabilities/default.json`:\n\n   ```diff\n   - \"window-state:default\"\n   ```\n",
  "local-ts/theming.md": "# Theming\n\nLocal.ts includes a complete theming system with light, dark, and system modes. The theme is persisted in settings and automatically applied on app launch.\n\n## How Theming Works\n\nThe theme system has two stores working together:\n\n1. **Settings Store** ‚Äî Persists the user's theme preference (`light`, `dark`, or `system`)\n2. **Theme Store** ‚Äî Manages the resolved theme and applies it to the DOM\n\nWhen the theme is `system`, the app listens for OS theme changes and updates automatically.\n\n## Theme Values\n\n| Value | Description |\n|-------|-------------|\n| `light` | Always use light mode |\n| `dark` | Always use dark mode |\n| `system` | Match the operating system preference |\n\n## Reading the Theme\n\nUse the `useTheme` hook to access theme state:\n\n```typescript\nimport { useTheme } from \"@/stores/theme\";\n\nfunction ThemeIndicator() {\n  // The user's preference: \"light\" | \"dark\" | \"system\"\n  const theme = useTheme((state) => state.theme);\n\n  // The actual applied theme: \"light\" | \"dark\"\n  const resolvedTheme = useTheme((state) => state.resolvedTheme);\n\n  return (\n    <div>\n      <p>Preference: {theme}</p>\n      <p>Applied: {resolvedTheme}</p>\n    </div>\n  );\n}\n```\n\n## Changing the Theme\n\nUse `setTheme` to update the theme. It automatically persists to settings:\n\n```typescript\nimport { useTheme } from \"@/stores/theme\";\n\nfunction ThemeSwitcher() {\n  const setTheme = useTheme((state) => state.setTheme);\n  const theme = useTheme((state) => state.theme);\n\n  return (\n    <div>\n      <button\n        onClick={() => setTheme(\"light\")}\n        data-active={theme === \"light\"}\n      >\n        Light\n      </button>\n      <button\n        onClick={() => setTheme(\"dark\")}\n        data-active={theme === \"dark\"}\n      >\n        Dark\n      </button>\n      <button\n        onClick={() => setTheme(\"system\")}\n        data-active={theme === \"system\"}\n      >\n        System\n      </button>\n    </div>\n  );\n}\n```\n\n## How Theme Application Works\n\nThe theme store applies themes by adding or removing the `dark` class on the document root:\n\n```typescript\nfunction getSystemTheme(): \"light\" | \"dark\" {\n  if (typeof window === \"undefined\") return \"light\";\n  return window.matchMedia(\"(prefers-color-scheme: dark)\").matches\n    ? \"dark\"\n    : \"light\";\n}\n\nfunction applyThemeToDOM(theme: Theme): \"light\" | \"dark\" {\n  const resolved = theme === \"system\" ? getSystemTheme() : theme;\n  const root = document.documentElement;\n\n  if (resolved === \"dark\") {\n    root.classList.add(\"dark\");\n  } else {\n    root.classList.remove(\"dark\");\n  }\n\n  return resolved;\n}\n```\n\nThis works with Tailwind CSS's dark mode variant. Style dark mode with the `dark:` prefix:\n\n```css\n.card {\n  background: white;\n}\n\n.dark .card {\n  background: #1a1a1a;\n}\n```\n\nOr with Tailwind utilities:\n\n```html\n<div class=\"bg-white dark:bg-gray-900\">\n  Content\n</div>\n```\n\nThe following line has already been included in your `styles/globals.css`:\n\n```css\n@custom-variant dark (&:where(.dark, .dark *));\n```\n\nThis line defines a custom CSS variant called `dark`. It allows you to target any element with the `dark` class, or any of its descendants, for dark mode styling.\n\nThis makes it easier to apply dark mode styles globally using the `.dark` class, especially when working with utility frameworks like Tailwind CSS.\n\nFor additional details, refer to [Tailwind's dark mode guide](https://tailwindcss.com/docs/dark-mode).\n\n## System Theme Detection\n\nThe theme store listens for system theme changes:\n\n```typescript\nexport const useTheme = create<ThemeStore>((set) => ({\n  // ...\n\n  initialize: () => {\n    const settings = useSettings.getState().settings;\n    if (settings) {\n      const resolved = applyThemeToDOM(settings.theme);\n      set({ theme: settings.theme, resolvedTheme: resolved });\n    }\n\n    const handleChange = () => {\n      const currentTheme = useTheme.getState().theme;\n      if (currentTheme === \"system\") {\n        const resolved = applyThemeToDOM(\"system\");\n        set({ resolvedTheme: resolved });\n      }\n    };\n\n    // Listen for system theme changes\n    const mediaQuery = window.matchMedia(\"(prefers-color-scheme: dark)\");\n    mediaQuery.addEventListener(\"change\", handleChange);\n  },\n}));\n```\n\nWhen the OS theme changes and the user has selected `system`, the app updates instantly.\n\n## CSS Variables\n\nLocal.ts uses CSS variables for colors, defined in `src/styles/globals.css`. You can customize the color palette:\n\n```css\n:root {\n  --background: 0 0% 100%;\n  --foreground: 240 10% 3.9%;\n  --primary: 240 5.9% 10%;\n  /* ... more variables */\n}\n\n.dark {\n  --background: 240 10% 3.9%;\n  --foreground: 0 0% 98%;\n  --primary: 0 0% 98%;\n  /* ... dark mode overrides */\n}\n```\n\nThen use them in your styles:\n\n```css\n.my-component {\n  background: hsl(var(--background));\n  color: hsl(var(--foreground));\n}\n```\n\n## Accessing Theme Outside React\n\nTo access Zustand store state outside of React components, use the following approach:\n\n```typescript\nimport { useTheme } from \"@/stores/theme\";\n\n// Get current theme\nconst { theme, resolvedTheme } = useTheme.getState();\n\n// Check if dark mode\nconst isDark = resolvedTheme === \"dark\";\n```\n",
  "local-ts/system-tray.md": "# System Tray\n\nThe system tray lets your app run in the background and provides quick access to common actions. Local.ts includes a fully configured system tray with show/hide controls and settings integration.\n\n## How It Works\n\nThe system tray provides:\n\n- **Tray icon** ‚Äî Your app icon appears in the system tray (menu bar on macOS, system tray on Windows/Linux)\n- **Right-click menu** ‚Äî Show, Hide, and Quit options\n- **Left-click behavior** ‚Äî Clicking the icon shows and focuses the main window\n- **Settings integration** ‚Äî Users can toggle tray visibility from the Settings page\n\n## Using the System Tray\n\nThe tray is automatically set up when your app starts. Users can control its visibility from Settings.\n\n### Toggle Tray Visibility\n\nFrom your React code:\n\n```typescript\nimport { setTrayVisible } from \"@/lib/tauri/settings\";\n\n// Show the tray icon\nawait setTrayVisible(true);\n\n// Hide the tray icon\nawait setTrayVisible(false);\n```\n\n### Check Current Visibility\n\nThe tray visibility is stored in settings:\n\n```typescript\nimport { useSettings } from \"@/stores/settings\";\n\nfunction TrayStatus() {\n  const settings = useSettings((state) => state.settings);\n\n  return (\n    <p>Tray is {settings?.showInTray ? \"visible\" : \"hidden\"}</p>\n  );\n}\n```\n\n## Customizing the Menu\n\nThe tray menu is defined in `src-tauri/src/plugins/system_tray.rs`. To add or modify menu items:\n\n```rust\nuse tauri::menu::{Menu, MenuItem};\n\npub fn setup(app: &App, pool: &DbPool) -> Result<(), Box<dyn std::error::Error>> {\n    // Create menu items\n    let show_i = MenuItem::with_id(app, \"show\", \"Show\", true, None::<&str>)?;\n    let hide_i = MenuItem::with_id(app, \"hide\", \"Hide\", true, None::<&str>)?;\n    let quit_i = MenuItem::with_id(app, \"quit\", \"Quit\", true, None::<&str>)?;\n\n    // Build the menu\n    let menu = Menu::with_items(app, &[&show_i, &hide_i, &quit_i])?;\n\n    // ... rest of setup\n}\n```\n\n### Handling Menu Events\n\nMenu events are handled in the `on_menu_event` callback:\n\n```rust\n.on_menu_event(|app, event| match event.id.as_ref() {\n    \"show\" => {\n        if let Some(window) = app.get_webview_window(\"main\") {\n            let _ = window.show();\n            let _ = window.set_focus();\n        }\n    }\n    \"hide\" => {\n        if let Some(window) = app.get_webview_window(\"main\") {\n            let _ = window.hide();\n        }\n    }\n    \"quit\" => {\n        app.exit(0);\n    }\n    \"my_custom_action\" => {\n        // Handle your custom action\n    }\n    _ => {}\n})\n```\n\n## Customizing Click Behavior\n\nThe left-click behavior shows and focuses the main window:\n\n```rust\n.on_tray_icon_event(|tray, event| {\n    if let TrayIconEvent::Click {\n        button: MouseButton::Left,\n        button_state: MouseButtonState::Up,\n        ..\n    } = event\n    {\n        let app = tray.app_handle();\n        if let Some(window) = app.get_webview_window(\"main\") {\n            let _ = window.show();\n            let _ = window.set_focus();\n        }\n    }\n})\n```\n\nTo open a specific page on click, emit an event or call a command from this handler.\n\n## Changing the Tray Icon\n\nThe tray uses your app's default icon. To use a different icon:\n\n```rust\nlet tray = TrayIconBuilder::new()\n    .icon(app.default_window_icon().unwrap().clone())\n    // ... rest of builder\n    .build(app)?;\n```\n\n## Removing the System Tray\n\nIf you don't need tray functionality:\n\n1. **Delete the module** ‚Äî Remove `src-tauri/src/plugins/system_tray.rs`\n\n2. **Remove the tray-icon feature** from `src-tauri/Cargo.toml`:\n\n   ```diff\n   - tauri = { version = \"2\", features = [\"tray-icon\"] }\n   + tauri = { version = \"2\", features = [] }\n   ```\n\n3. **Remove setup and command** from `src-tauri/src/lib.rs`:\n\n   ```diff\n   - plugins::system_tray::setup(app, &pool)?;\n   ```\n\n   ```diff\n   .invoke_handler(tauri::generate_handler![\n       commands::settings::get_app_settings,\n       commands::settings::update_app_settings,\n   -   commands::settings::set_tray_visible,\n   ])\n   ```\n\n4. **Update the plugins module** ‚Äî Remove the export from `src-tauri/src/plugins/mod.rs`\n\n## Learn More\n\n- [Tauri System Tray Documentation](https://v2.tauri.app/learn/system-tray/) ‚Äî Official Tauri menu and tray icon documentation\n",
  "local-ts/splash-screen.md": "# Splash Screen\n\nLocal.ts includes a splash screen that displays while your app initializes. This creates a polished first impression and prevents users from seeing an empty window during startup.\n\n## How It Works\n\nThe splash screen uses Tauri's multi-window feature:\n\n1. **On launch** ‚Äî The splash screen window shows immediately while the main window stays hidden\n2. **During initialization** ‚Äî Your app loads settings, connects to the database, and sets up stores\n3. **When ready** ‚Äî The splash closes and the main window appears\n\nThis ensures users see a branded loading experience instead of a blank window.\n\n## Window Configuration\n\nThe windows are defined in `src-tauri/tauri.conf.json`:\n\n```json\n{\n  \"windows\": [\n    {\n      \"title\": \"Local.ts\",\n      \"label\": \"main\",\n      \"visible\": false,\n      \"width\": 1280,\n      \"height\": 720,\n      \"center\": true\n    },\n    {\n      \"title\": \"Loading...\",\n      \"label\": \"splashscreen\",\n      \"url\": \"splash.html\",\n      \"width\": 1280,\n      \"height\": 720,\n      \"center\": true,\n      \"decorations\": false\n    }\n  ]\n}\n```\n\nNote that `main` has `visible: false` so it stays hidden until initialization completes.\n\n## Closing the Splash Screen\n\nThe `close_splashscreen` command in Rust closes the splash and shows the main window:\n\n```rust\n#[tauri::command]\npub fn close_splashscreen(window: tauri::Window) {\n    if let Some(splash) = window.get_webview_window(\"splashscreen\") {\n        let _ = splash.close();\n    }\n    if let Some(main) = window.get_webview_window(\"main\") {\n        let _ = main.show();\n        let _ = main.set_focus();\n    }\n}\n```\n\nThis is called from the React `StoreInitializer` component after all initialization completes:\n\n```typescript\nuseEffect(() => {\n  const init = async () => {\n    try {\n      await initializeSettings();\n      initializeTheme();\n      setIsInitialized(true);\n\n      // Close splash screen and show main window\n      await invoke(\"close_splashscreen\");\n    } catch (err) {\n      console.error(\"Failed to initialize:\", err);\n      setError(err);\n\n      // Still close splash on error to show error UI\n      await invoke(\"close_splashscreen\").catch(console.error);\n    }\n  };\n\n  init();\n}, []);\n```\n\n## Customizing the Splash Screen\n\nTo customize the splash screen, modify `splash.html` located at your project root. Here is the default template:\n\n```html\n<!doctype html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <link rel=\"stylesheet\" href=\"/src/styles/globals.css\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n    <title>Loading...</title>\n  </head>\n  <body>\n    <div class=\"container flex flex-col items-center justify-center h-screen\">\n      <h1 class=\"text-2xl font-bold text-foreground\">Local.ts</h1>\n      <p class=\"mt-2 text-muted-foreground\">\n        A starter kit for building local-first applications\n      </p>\n    </div>\n  </body>\n</html>\n```\n\n## Changing Splash Window Size\n\nIn `tauri.conf.json`:\n\n```json\n{\n  \"label\": \"splashscreen\",\n  \"url\": \"splash.html\",\n  \"width\": 400,\n  \"height\": 300,\n  \"center\": true,\n  \"decorations\": false\n}\n```\n\nSetting `decorations: false` removes the window title bar for a cleaner look.\n\n## Error Handling with Retry\n\nIf initialization fails (for example, a database connection error), the `StoreInitializer` component displays an error screen with a retry button instead of leaving users stuck on the splash screen.\n\nThe component tracks error state and provides a retry mechanism:\n\n```typescript\nconst [error, setError] = useState<Error | null>(null);\n\nconst handleRetry = async () => {\n  setError(null);\n  setIsInitialized(false);\n\n  try {\n    await initializeSettings();\n    initializeTheme();\n    setIsInitialized(true);\n  } catch (err) {\n    console.error(\"Retry failed:\", err);\n    setError(err instanceof Error ? err : new Error(\"Unknown error\"));\n  }\n};\n\nif (error) {\n  return <InitializationError error={error} onRetry={handleRetry} />;\n}\n```\n\nThe error UI component shows a clear message and retry button:\n\n```typescript\nfunction InitializationError({ error, onRetry }: InitializationErrorProps) {\n  return (\n    <div className=\"flex h-screen flex-col items-center justify-center gap-4 p-6\">\n      <div className=\"text-center\">\n        <h1 className=\"text-2xl font-bold text-destructive\">\n          Initialization Error\n        </h1>\n        <p className=\"mt-2 text-muted-foreground\">\n          Failed to load application settings\n        </p>\n        <p className=\"mt-1 text-sm text-muted-foreground\">{error.message}</p>\n      </div>\n      <button\n        type=\"button\"\n        onClick={onRetry}\n        className=\"rounded-md bg-primary px-4 py-2 text-sm font-medium text-primary-foreground hover:bg-primary/90\"\n      >\n        Retry\n      </button>\n    </div>\n  );\n}\n```\n\nThis ensures users always have a path forward, even when something goes wrong during app startup.\n\n## Removing the Splash Screen\n\nIf you prefer to show the main window immediately:\n\n1. **Update `tauri.conf.json`**:\n\n   ```diff\n     \"windows\": [\n       {\n         \"title\": \"Local.ts\",\n         \"label\": \"main\",\n   -     \"visible\": false,\n   +     \"visible\": true,\n         \"width\": 1280,\n         \"height\": 720\n       },\n   -   {\n   -     \"title\": \"Loading...\",\n   -     \"label\": \"splashscreen\",\n   -     \"url\": \"splash.html\",\n   -     \"width\": 1280,\n   -     \"height\": 720\n   -   }\n     ]\n   ```\n\n2. **Delete `splash.html`**\n\n3. **Remove the window command** ‚Äî Delete `src-tauri/src/commands/window.rs`\n\n4. **Update commands module** ‚Äî Remove the export from `src-tauri/src/commands/mod.rs`\n\n5. **Unregister the command** from `src-tauri/src/lib.rs`:\n\n   ```diff\n   .invoke_handler(tauri::generate_handler![\n       commands::settings::get_app_settings,\n       commands::settings::update_app_settings,\n       commands::settings::set_tray_visible,\n   -   commands::window::close_splashscreen,\n   ])\n   ```\n\n6. **Remove the invoke call** from `src/components/store-initializer.tsx`:\n\n   ```diff\n   - await invoke(\"close_splashscreen\");\n   ```\n\n## Learn More\n\nLearn more about [Tauri splash screens](https://v2.tauri.app/learn/splashscreen/) by checking the official documentation.\n",
  "local-ts/sidebar.md": "# Sidebar Navigation\n\nLocal.ts includes a pre-made sidebar component that's entirely customizable.\n\nIt exists to help you start building faster, but you can modify or replace it completely to match your app's needs.\n\n## Customizing Sidebar Links\n\nThe sidebar navigation is configured in `src/constants/sidebar.ts`. This file exports two arrays that define the items shown at the top and bottom of the sidebar.\n\n### Basic Structure\n\n```typescript\nimport { Home, Settings } from \"lucide-react\";\nimport type { SidebarItem } from \"@/components/ui/sidebar/sidebar-nav-item\";\n\nexport const SIDEBAR_TOP_ITEMS: SidebarItem[] = [\n  { icon: Home, label: \"Home\", href: \"/\" },\n];\n\nexport const SIDEBAR_BOTTOM_ITEMS: SidebarItem[] = [\n  { icon: Settings, label: \"Settings\", href: \"/settings\" },\n];\n```\n\nEach `SidebarItem` has three properties:\n\n| Property | Type | Description |\n|----------|------|-------------|\n| `icon` | `LucideIcon` | A Lucide React icon component |\n| `label` | `string` | Display name shown in the sidebar |\n| `href` | `string` | Route path (must match a route in `src/routes/`) |\n\n## Adding New Links\n\nTo add a new sidebar item:\n\n### 1. Import the Icon\n\nChoose an icon from [Lucide Icons](https://lucide.dev/icons/) and import it:\n\n```typescript\nimport { Home, Settings, Users, Activity } from \"lucide-react\";\n```\n\n### 2. Add the Item\n\nAdd the new item to either `SIDEBAR_TOP_ITEMS` or `SIDEBAR_BOTTOM_ITEMS`:\n\n```typescript\nexport const SIDEBAR_TOP_ITEMS: SidebarItem[] = [\n  { icon: Home, label: \"Home\", href: \"/\" },\n  { icon: Activity, label: \"Dashboard\", href: \"/dashboard\" },\n];\n```\n\n### 3. Create the Corresponding Route\n\nMake sure the route exists in your `src/routes/` directory. For example, for `/dashboard`, create:\n\n```\nsrc/routes/dashboard.tsx\n```\n\n::: tip\nThe sidebar automatically highlights the active route based on the current URL.\n:::\n\n## Ordering Items\n\nItems appear in the order they're defined in the array:\n\n- **Top items** ‚Äî Primary navigation links (top of sidebar)\n- **Bottom items** ‚Äî Secondary actions like Settings (bottom of sidebar)\n\n## Using Different Icons\n\nLocal.ts uses [Lucide React](https://lucide.dev/) for icons. You can:\n\n1. **Browse available icons** at [lucide.dev/icons](https://lucide.dev/icons/)\n2. **Import any icon** using the PascalCase name:\n   ```typescript\n   import { FileText, Calendar, Mail, Bell } from \"lucide-react\";\n   ```\n\n## Customizing the Sidebar Component\n\nThe sidebar component itself is located at `src/components/sidebar.tsx`. You can modify:\n\n- **Styling** ‚Äî Adjust colors, spacing, and animations\n- **Layout** ‚Äî Change the sidebar width or positioning\n- **Behavior** ‚Äî Add tooltips, badges, or collapse functionality\n- **Structure** ‚Äî Reorganize or add new sections\n\n::: info\nThe sidebar is just a React component. You're free to completely rewrite it or use a different navigation pattern if needed.\n:::\n\n## Removing Items\n\nSimply delete items you don't need:\n\n```diff\nexport const SIDEBAR_TOP_ITEMS: SidebarItem[] = [\n  { icon: Home, label: \"Home\", href: \"/\" },\n- { icon: Users, label: \"Team\", href: \"/team\" },\n];\n```\n\n## TypeScript Support\n\nThe `SidebarItem` type provides full TypeScript support. If you need to add custom properties, extend the type in `src/components/ui/sidebar/sidebar-nav-item.tsx`:\n\n```typescript\nexport interface SidebarItem {\n  icon: LucideIcon;\n  label: string;\n  href: string;\n  badge?: number; // Optional badge count\n  disabled?: boolean; // Optional disabled state\n}\n```\n",
  "local-ts/settings.md": "# Settings\n\nLocal.ts includes a complete settings system with persistent storage, type-safe APIs, and a pre-built Settings page.\n\n## Understanding the Settings System\n\nSettings in Local.ts flow through a layered architecture:\n\n1. **Models** (`database/models/settings.rs`) ‚Äî Data structures and type definitions\n2. **Services** (`services/settings.rs`) ‚Äî Database operations (get/update settings)\n3. **Commands** (`commands/settings.rs`) ‚Äî Tauri handlers that call services\n4. **Frontend** ‚Äî Zustand store and React hooks\n\nWhen you update a setting, it flows from the frontend through commands and services to the database, then syncs back to the UI.\n\n## Available Settings\n\n| Category | Setting | Description | Default |\n|----------|---------|-------------|---------|\n| Appearance | Theme | Light, dark, or system | `system` |\n| | Sidebar Expanded | Keep sidebar open | `true` |\n| Behavior | Show in System Tray | Display tray icon | `true` |\n| | Launch at Login | Auto-start with system | `false` |\n| Notifications | Enable Notifications | Allow native notifications | `true` |\n| Developer | Enable Logging | Record application logs | `true` |\n| | Log Level | Minimum severity to log | `info` |\n\n## Reading Settings\n\nUse the `useSettings` hook to access settings in your components:\n\n```typescript\nimport { useSettings } from \"@/stores/settings\";\n\nfunction MyComponent() {\n  const settings = useSettings((state) => state.settings);\n\n  if (!settings) return null;\n\n  return (\n    <div>\n      <p>Current theme: {settings.theme}</p>\n      <p>Logging enabled: {settings.enableLogging ? \"Yes\" : \"No\"}</p>\n    </div>\n  );\n}\n```\n\n## Updating Settings\n\nCall `updateSettings` with a partial settings object. Only the fields you provide will be updated:\n\n```typescript\nimport { useSettings } from \"@/stores/settings\";\n\nfunction ThemeToggle() {\n  const updateSettings = useSettings((state) => state.updateSettings);\n\n  const switchToDark = async () => {\n    await updateSettings({ theme: \"dark\" });\n  };\n\n  return <button onClick={switchToDark}>Dark Mode</button>;\n}\n```\n\nYou can update multiple settings at once:\n\n```typescript\nawait updateSettings({\n  theme: \"light\",\n  enableLogging: true,\n  logLevel: \"debug\",\n});\n```\n\n## Accessing Settings Outside React\n\nFor non-React code, access the store directly:\n\n```typescript\nimport { useSettings } from \"@/stores/settings\";\n\n// Get current settings\nconst settings = useSettings.getState().settings;\n\n// Update settings\nawait useSettings.getState().updateSettings({ theme: \"dark\" });\n```\n\n## TypeScript Types\n\nSettings have full TypeScript support. Import the types for use in your code:\n\n```typescript\nimport type { Settings, SettingsUpdate, Theme, LogLevel } from \"@/lib/tauri/settings/types\";\n\n// Theme: \"light\" | \"dark\" | \"system\"\n// LogLevel: \"error\" | \"warn\" | \"info\" | \"debug\" | \"trace\"\n\nfunction processSettings(settings: Settings) {\n  console.log(settings.theme);\n}\n```\n\nThe `Settings` interface:\n\n```typescript\ninterface Settings {\n  theme: Theme;\n  sidebarExpanded: boolean;\n  showInTray: boolean;\n  launchAtLogin: boolean;\n  enableLogging: boolean;\n  logLevel: LogLevel;\n  enableNotifications: boolean;\n}\n```\n\n## Adding New Settings\n\nTo add a new setting, you need to update both the backend and frontend.\n\n### 1. Create a Database Migration\n\nGenerate a new migration:\n\n```bash\ncd src-tauri\ndiesel migration generate add_my_setting\n```\n\nWrite the SQL in `up.sql`:\n\n```sql\nALTER TABLE settings ADD COLUMN my_setting INTEGER NOT NULL DEFAULT 0;\n```\n\nAnd the rollback in `down.sql`:\n\n```sql\nALTER TABLE settings DROP COLUMN my_setting;\n```\n\nRun the migration:\n\n```bash\ndiesel migration run\n```\n\n### 2. Update the Rust Models\n\nIn `src-tauri/src/database/models/settings.rs`, add the field to each struct:\n\n```rust\n// In SettingsRow\npub struct SettingsRow {\n    // ... existing fields\n    pub my_setting: i32,\n}\n\n// In Settings\npub struct Settings {\n    // ... existing fields\n    pub my_setting: bool,\n}\n\n// In SettingsUpdate\npub struct SettingsUpdate {\n    // ... existing fields\n    pub my_setting: Option<bool>,\n}\n\n// In SettingsChangeset\npub struct SettingsChangeset {\n    // ... existing fields\n    pub my_setting: Option<i32>,\n}\n```\n\nUpdate the `from_row` and `From<SettingsUpdate>` implementations to handle the new field.\n\n### 3. Update TypeScript Types\n\nIn `src/lib/tauri/settings/types.ts`:\n\n```typescript\nexport interface Settings {\n  // ... existing fields\n  mySetting: boolean;\n}\n```\n\n### 4. Add UI Controls\n\nAdd a toggle or input in `src/routes/settings.tsx` for users to modify the setting.\n",
  "local-ts/project-identity.md": "# Project Identity\n\nAfter cloning Local.ts, you'll want to update several files to match your project's name, description, and branding.\n\n## Files to Update\n\n| File | Fields to Update |\n|------|------------------|\n| `package.json` | `name`, `version`, `description` |\n| `index.html` | `title` |\n| `src/constants/index.ts` | `APP_TITLE` |\n| `src-tauri/Cargo.toml` | `name`, `version`, `description`, `authors` |\n| `src-tauri/tauri.conf.json` | `productName`, `version`, `identifier` |\n| `splash.html` | App name and description text |\n\n## Step-by-Step Guide\n\n### 1. Update package.json\n\n```json\n{\n  \"name\": \"my-awesome-app\",\n  \"version\": \"1.0.0\",\n  \"description\": \"A brief description of your app\"\n}\n```\n\n### 2. Update index.html\n\n```html\n<title>My Awesome App</title>\n```\n\n### 3. Update App Constants\n\nIn `src/constants/index.ts`:\n\n```typescript\nexport const APP_TITLE = \"My Awesome App\";\n```\n\nThis constant is used throughout the frontend for window titles and UI elements.\n\n### 4. Update Cargo.toml\n\nIn `src-tauri/Cargo.toml`:\n\n```toml\n[package]\nname = \"my-awesome-app\"\nversion = \"1.0.0\"\ndescription = \"A brief description of your app\"\nauthors = [\"Your Name <you@example.com>\"]\n```\n\n### 5. Update Tauri Configuration\n\nIn `src-tauri/tauri.conf.json`:\n\n```json\n{\n  \"productName\": \"My Awesome App\",\n  \"version\": \"1.0.0\",\n  \"identifier\": \"com.yourcompany.myawesomeapp\"\n}\n```\n\nThe `identifier` should be a unique reverse-domain identifier for your app. This is used for:\n- macOS bundle identifier\n- Windows application ID\n- Linux desktop file\n\n### 6. Update Splash Screen\n\nIn `splash.html`, update the visible text:\n\n```html\n<h1>My Awesome App</h1>\n<p>Loading your awesome experience...</p>\n```\n\n## Bundle Identifier\n\nThe bundle identifier in `tauri.conf.json` is important for:\n\n| Platform | Usage |\n|----------|-------|\n| macOS | Bundle ID, code signing, App Store |\n| Windows | Application User Model ID |\n| Linux | Desktop entry file name |\n\nChoose a unique identifier following reverse-domain notation. Here are some examples:\n- `com.yourcompany.appname` ‚Äî For company apps\n- `dev.yourname.appname` ‚Äî For personal projects\n- `io.github.username.appname` ‚Äî For open source projects\n\n## Version Management\n\nKeep versions synchronized across all configuration files. When releasing a new version, update:\n\n1. `package.json`\n2. `src-tauri/Cargo.toml`\n3. `src-tauri/tauri.conf.json`\n\n::: tip\nConsider using a tool like [changesets](https://github.com/changesets/changesets) to manage versioning across the monorepo.\n:::\n",
  "local-ts/notifications.md": "# Notifications\n\nLocal.ts includes native notification support with permission handling and user preferences.\n\nThus, you can send system notifications that respect user settings and platform requirements.\n\n## Understanding Notifications\n\nNotifications in Local.ts have two layers of control:\n\n1. **System permissions** ‚Äî The OS must grant notification access\n2. **User preferences** ‚Äî Users can disable notifications in Settings\n\nThe notification helpers handle both automatically, so you can focus on when and what to notify.\n\n## Sending Notifications\n\n### Basic Notification\n\nUse `notify()` to send a notification that respects user preferences:\n\n```typescript\nimport { notify } from \"@/lib/tauri/notifications/send\";\nimport { useSettings } from \"@/stores/settings\";\n\nasync function sendNotification() {\n  const settings = useSettings.getState().settings;\n  if (!settings) return;\n\n  const sent = await notify({\n    title: \"Task Complete\",\n    body: \"Your export has finished successfully.\",\n  }, settings);\n\n  if (sent) {\n    console.log(\"Notification delivered\");\n  } else {\n    console.log(\"Notification blocked by settings or permissions\");\n  }\n}\n```\n\n### Critical Notifications\n\nFor urgent alerts that should bypass user preferences (but still require system permission):\n\n```typescript\nimport { notifyForced } from \"@/lib/tauri/notifications/send\";\n\nasync function sendCriticalAlert() {\n  await notifyForced({\n    title: \"Critical Error\",\n    body: \"Your data could not be saved. Please try again.\",\n  });\n}\n```\n\n::: warning\nUse `notifyForced` sparingly. Overusing it will frustrate users who have disabled notifications.\n:::\n\n## Notification Options\n\nBoth `notify` and `notifyForced` accept the same options:\n\n```typescript\ninterface NotificationOptions {\n  title: string;      // Required: notification title\n  body?: string;      // Optional: notification body text\n  icon?: string;      // Optional: path to icon file\n}\n```\n\nExample with all options:\n\n```typescript\nawait notify({\n  title: \"New Message\",\n  body: \"You have a new message from Alice\",\n  icon: \"icons/message.png\",\n}, settings);\n```\n\n::: tip\nYou can change this `NotificationOptions` interface however you want and modify the `notify` and `notifyForced` helpers to add more fields according to the [Tauri notification plugin options](https://v2.tauri.app/reference/javascript/notification/#sendnotification).\n:::\n\n## Checking Permissions\n\nBefore showing notifications, ensure you have permission:\n\n```typescript\nimport {\n  isPermissionGranted,\n  requestPermission,\n} from \"@tauri-apps/plugin-notification\";\n\n// Check current permission status\nconst hasPermission = await isPermissionGranted();\n\n// Request permission (shows system prompt if needed)\nconst granted = await requestPermission();\nif (granted) {\n  console.log(\"Notifications enabled\");\n}\n```\n\nYou can use the following convenient helper to ensure notification permission is granted (it checks and requests if needed):\n\n```typescript\n// src/lib/tauri/notifications/permissions.ts\nimport {\n  isPermissionGranted,\n  requestPermission,\n} from \"@tauri-apps/plugin-notification\";\n\n/**\n * Ensure notification permission is granted\n * Requests permission if not already granted\n */\nexport async function ensureNotificationPermission(): Promise<NotificationPermission> {\n  const granted = await isPermissionGranted();\n  if (granted) {\n    return \"granted\";\n  }\n  return await requestPermission();\n}\n```\n\n## User Preferences\n\nThe Settings page includes a notification toggle. When users enable notifications, permission is automatically requested:\n\n```typescript\nimport { requestPermission } from \"@tauri-apps/plugin-notification\";\n\n// simplified implementation\nconst handleNotificationChange = async (enabled: boolean) => {\n  // If enabling notifications, request permission first\n  if (enabled) {\n    const granted = await requestPermission();\n    if (granted !== \"granted\") {\n      // Permission denied, don't enable notifications\n      return;\n    }\n  }\n};\n```\n\n## How It Works\n\nThe `notify` function implements this logic:\n\n```typescript\nexport async function notify(\n  options: NotificationOptions,\n  settings: Settings\n): Promise<boolean> {\n  // 1. Check user preferences\n  if (!settings.enableNotifications) {\n    return false;\n  }\n\n  // 2. Ensure system permission\n  const granted = await ensureNotificationPermission();\n  if (granted !== \"granted\") {\n    return false;\n  }\n\n  // 3. Send the notification\n  sendNotification({\n    title: options.title,\n    body: options.body,\n    icon: options.icon,\n  });\n\n  return true;\n}\n```\n\n## Removing Notifications\n\nIf you don't need notification functionality:\n\n1. **Remove the plugin** from `src-tauri/src/lib.rs`:\n\n   ```diff\n   - .plugin(tauri_plugin_notification::init())\n   ```\n\n2. **Remove the dependency** from `src-tauri/Cargo.toml`:\n\n   ```diff\n   - tauri-plugin-notification = \"2\"\n   ```\n\n3. **Remove permissions** from `src-tauri/capabilities/default.json`:\n\n   ```diff\n   - \"notification:default\"\n   ```\n\n4. **Remove the npm package**:\n\n   ```bash\n   pnpm remove @tauri-apps/plugin-notification\n   ```\n\n5. **Delete the notifications module** ‚Äî Remove `src/lib/tauri/notifications/`\n",
  "local-ts/motivation.md": "# Why Local.ts?\n\nLocal.ts was created to solve a common problem: **building desktop apps with web technologies takes too long to set up right**.\n\n## The Challenge\n\nStarting a new desktop app project typically means:\n\n- **Days of boilerplate** ‚Äî Setting up Tauri with React, TypeScript, and Rust requires significant configuration\n- **Endless decisions** ‚Äî State management, theming, database layer, testing setup... each choice takes time\n- **Missing patterns** ‚Äî Most starters are \"hello world\" examples that don't show production patterns\n- **Fragmented docs** ‚Äî Piecing together tutorials for each technology in the stack\n\nWe wanted to skip straight to building features.\n\n## The Rise of Homemade Tools\n\nAI is fundamentally changing how software gets built. With coding assistants and AI-powered development tools, **creating custom applications is now accessible to everyone** ‚Äî not just professional developers.\n\nThis shift will lead to a rise in homemade tools:\n\n| Trend | Implication |\n|-------|-------------|\n| **Lower barrier to entry** | More people building personal tools instead of relying on SaaS |\n| **Data ownership** | Users want control over their data, not rental agreements |\n| **Custom workflows** | Generic tools can't match purpose-built solutions |\n\nWhen everyone can build their own tools, why trust your data to companies that might:\n- Sell your information\n- Get breached\n- Shut down and lose your data\n- Change pricing or terms\n\n**Local-first software puts you back in control.**\n\n### Own Your Data, Own Your Backups\n\nWith local-first apps:\n\n- **Your data stays on your device** ‚Äî No cloud servers to breach\n- **You control backups** ‚Äî Export, sync, or replicate however you want\n- **No vendor lock-in** ‚Äî SQLite files are portable and open\n- **Works forever** ‚Äî Apps don't disappear when companies do\n\nLocal.ts makes it easy to build these kinds of tools. Combined with AI assistants, you can create exactly the software you need ‚Äî with the privacy guarantees you deserve.\n\n## Why Local-First?\n\nLocal.ts embraces a local-first architecture where your app's data lives on the user's device:\n\n| Benefit | Description |\n|---------|-------------|\n| **Privacy** | User data never leaves their machine unless they choose to sync |\n| **Offline-ready** | Works without internet connection |\n| **Performance** | No network latency ‚Äî everything is instant |\n| **No server costs** | Ship apps without backend infrastructure |\n| **Reliability** | No dependencies on external services |\n\nLocal-first doesn't mean \"never online.\" You can add sync, cloud backups, or API integrations when needed. But starting local-first gives you a solid foundation.\n\n## Why This Stack?\n\nEvery technology in Local.ts was chosen for a reason:\n\n### Tauri v2\n\n- **Tiny binaries** ‚Äî 10-20MB vs 150MB+ for Electron\n- **Native performance** ‚Äî Uses system webview, not bundled Chromium\n- **Cross-platform** ‚Äî macOS, Windows, and Linux from one codebase\n- **Security-focused** ‚Äî Rust backend with fine-grained permissions\n\n### React + TypeScript\n\n- **Familiar ecosystem** ‚Äî Use the libraries you already know\n- **Type safety** ‚Äî Catch errors at compile time\n- **Component model** ‚Äî Build UIs from composable pieces\n- **Huge community** ‚Äî Answers for every question\n\n### Rust Backend\n\n- **Memory safety** ‚Äî No null pointers, no data races\n- **Performance** ‚Äî Native speed for file operations, database queries\n- **Reliability** ‚Äî If it compiles, it usually works\n- **Growing ecosystem** ‚Äî Excellent libraries for desktop development\n\n### SQLite + Diesel\n\n- **Embedded database** ‚Äî No server to install or manage\n- **Battle-tested** ‚Äî Powers billions of devices worldwide\n- **Type-safe queries** ‚Äî Diesel catches SQL errors at compile time\n- **Migrations** ‚Äî Version your schema with confidence\n\n## What Local.ts Provides\n\nThis isn't a minimal starter. It's a production-ready foundation:\n\n### Core Features\n- **Settings system** ‚Äî Persistent preferences with React integration\n- **Theming** ‚Äî Light, dark, and system themes with CSS variables\n- **Database layer** ‚Äî SQLite with migrations, models, services, and commands\n- **Logging** ‚Äî Structured logs to files and console\n\n### Desktop Integration\n- **System tray** ‚Äî Background operation with menu actions\n- **Notifications** ‚Äî Native OS notifications\n- **Autostart** ‚Äî Launch at login option\n- **Window state** ‚Äî Remembers size and position\n\n### Developer Experience\n- **Turborepo** ‚Äî Orchestrated builds across TypeScript and Rust\n- **Ultracite** ‚Äî Fast linting and formatting (oxlint + oxfmt)\n- **Vitest** ‚Äî Modern testing with coverage\n- **Pre-commit hooks** ‚Äî Automated quality checks\n\n### Architecture\n- **Layered design** ‚Äî Clear separation between frontend, commands, services, and models\n- **Type safety** ‚Äî End-to-end types from Rust to React\n- **Extensible patterns** ‚Äî Add features following established conventions\n\n## Who Is This For?\n\nLocal.ts is ideal for:\n\n- **Web developers** who want to build desktop apps without learning a new paradigm\n- **Teams** who need a consistent, well-documented starting point\n- **Solo developers** who want to ship desktop apps quickly\n- **AI-assisted builders** who want a solid foundation to extend with AI tools\n- **Anyone** who values user privacy and data ownership\n\n## Getting Started\n\nReady to build your first local-first desktop app?\n\n<div class=\"tip custom-block\" style=\"padding-top: 8px\">\n\nCheck out the [Getting Started guide](./getting-started) to create your first Local.ts app in minutes.\n\n</div>\n",
  "local-ts/logging.md": "# Logging\n\nLocal.ts includes built-in logging powered by the [Tauri logging plugin](https://github.com/tauri-apps/tauri-plugin-log) and the basic Rust [log crate](https://docs.rs/log/latest/log/).\n\nLogs are sent to the console, browser devtools, and persistent files for debugging production issues.\n\n## How Logging Works\n\nThe logging system outputs to three targets simultaneously:\n\n1. **Console (stdout)** ‚Äî For development, visible in the terminal\n2. **Webview console** ‚Äî Rust logs appear in browser devtools\n3. **Log files** ‚Äî Persistent logs stored on disk with automatic rotation\n\n## Log Levels\n\n| Level | Description | Use Case |\n|-------|-------------|----------|\n| `error` | Critical failures | Database errors, crashes |\n| `warn` | Potential issues | Deprecated usage, recoverable errors |\n| `info` | General information | App started, user actions |\n| `debug` | Detailed debugging | Function calls, state changes |\n| `trace` | Very verbose | Request/response data, loops |\n\n## Logging from Rust\n\nUse the standard Rust `log` macros:\n\n```rust\nlog::info!(\"Application started\");\nlog::debug!(\"Processing user: {}\", user_id);\nlog::warn!(\"Deprecated API called\");\nlog::error!(\"Failed to save settings: {}\", error);\n```\n\n## Logging from JavaScript\n\nImport and use the Tauri log plugin:\n\n```typescript\nimport { info, debug, warn, error, trace } from \"@tauri-apps/plugin-log\";\n\nawait info(\"User clicked button\");\nawait debug(`Processing item ${itemId}`);\nawait warn(\"This feature is deprecated\");\nawait error(\"Failed to fetch data\");\n```\n\n## Log File Location\n\nLog files are stored in the platform-specific log directory:\n\n| Platform | Location |\n|----------|----------|\n| macOS | `~/Library/Logs/{bundleIdentifier}/logs.log` |\n| Windows | `C:\\Users\\{User}\\AppData\\Local\\{bundleIdentifier}\\logs\\logs.log` |\n| Linux | `~/.local/share/{bundleIdentifier}/logs/logs.log` |\n\nFiles rotate automatically at 50KB to prevent unbounded growth.\n\n## Configuration\n\nThe logging configuration is in `src-tauri/src/plugins/logging.rs`:\n\n```rust\nuse tauri_plugin_log::{Target, TargetKind, TimezoneStrategy};\n\npub fn build() -> tauri_plugin_log::Builder {\n    tauri_plugin_log::Builder::new()\n        .targets([\n            Target::new(TargetKind::Stdout),\n            Target::new(TargetKind::Webview),\n            Target::new(TargetKind::LogDir {\n                file_name: Some(\"logs\".to_string()),\n            }),\n        ])\n        .timezone_strategy(TimezoneStrategy::UseLocal)\n        .max_file_size(50_000)\n}\n```\n\n### Change File Rotation Size\n\n```rust\n.max_file_size(100_000)  // 100KB per file\n```\n\n### Use UTC Timestamps\n\n```rust\n.timezone_strategy(TimezoneStrategy::UseUtc)\n```\n\n### Filter by Log Level\n\nSet the minimum log level:\n\n```rust\n.level(log::LevelFilter::Info)\n```\n\nSet different levels for specific modules:\n\n```rust\n.level(log::LevelFilter::Info)\n.level_for(\"my_app::database\", log::LevelFilter::Debug)\n```\n\n### Log to Separate Files by Level\n\n```rust\n.targets([\n    Target::new(TargetKind::Stdout),\n    Target::new(TargetKind::LogDir { file_name: Some(\"errors\".to_string()) })\n        .filter(|metadata| metadata.level() == log::Level::Error),\n    Target::new(TargetKind::LogDir { file_name: Some(\"all\".to_string()) }),\n])\n```\n\n### Disable Console Logging in Production\n\n```rust\nlet targets = if cfg!(debug_assertions) {\n    vec![\n        Target::new(TargetKind::Stdout),\n        Target::new(TargetKind::Webview),\n        Target::new(TargetKind::LogDir { file_name: Some(\"logs\".to_string()) }),\n    ]\n} else {\n    vec![\n        Target::new(TargetKind::LogDir { file_name: Some(\"logs\".to_string()) }),\n    ]\n};\n\ntauri_plugin_log::Builder::new().targets(targets)\n```\n\n## User-Configurable Logging\n\nThe Settings page includes toggles for logging and log level. Read these settings in your Rust code to adjust logging behavior:\n\n```rust\nlet settings = get_settings(&mut conn)?;\nif settings.enable_logging {\n    log::info!(\"Detailed logging enabled at level: {:?}\", settings.log_level);\n}\n```\n\nRefer to your settings module or database queries for the actual `get_settings` function signature.\n\n## Viewing Logs\n\n### During Development\n\nLogs appear in your terminal when running `turbo tauri -- dev`.\n\n### In Browser DevTools\n\nOpen devtools in your app window (Cmd+Option+I on macOS, F12 on Windows/Linux) to see Rust logs in the console.\n\n### Reading Log Files\n\nNavigate to the log directory for your platform and open the log file in any text editor.\n\n## Removing Logging\n\nIf you don't need logging:\n\n1. **Delete the logging module** ‚Äî Remove `src-tauri/src/plugins/logging.rs`\n\n2. **Remove dependencies** from `src-tauri/Cargo.toml`:\n\n   ```diff\n   - tauri-plugin-log = \"2\"\n   - log = \"0.4\"\n   ```\n\n3. **Remove the plugin** from `src-tauri/src/lib.rs`:\n\n   ```diff\n   - .plugin(plugins::logging::build().build())\n   ```\n\n4. **Remove permissions** from `src-tauri/capabilities/default.json`:\n\n   ```diff\n   - \"log:default\"\n   ```\n\n5. **Remove the npm package**:\n\n   ```bash\n   pnpm remove @tauri-apps/plugin-log\n   ```\n",
  "local-ts/index.md": "# Local.ts\n\nA starter kit for building local-first applications for desktop and mobile.\n\n## What is Local.ts?\n\nLocal.ts is a production-ready template for building cross-platform desktop applications with a local-first architecture.\n\nYour data stays on the user's device, always available offline, with native performance and a small bundle size.\n\nBuilt with **React**, **TypeScript**, **Tauri**, and **Rust**, Local.ts provides everything you need to ship a polished desktop app: persistent settings, system tray integration, notifications, database storage, and more.\n\n::: tip\nSince Local.ts relies heavily on Tauri, we highly recommend checking the [Tauri documentation](https://tauri.app/develop/) for deeper understanding of the platform and advanced customization options.\n:::\n\n## Features\n\n- **Local-first** ‚Äî Your data stays on the device, always available offline\n- **Cross-platform** ‚Äî Build for macOS, Windows, Linux, iOS, and Android\n- **Lightweight** ‚Äî Native performance with a small bundle size\n- **Secure** ‚Äî Built-in Content Security Policy and Tauri's security model\n\n### Built-in Functionality\n\n| Feature | Description |\n|---------|-------------|\n| [Settings](/local-ts/settings) | Persistent settings with theme, behavior, and developer options |\n| [System Tray](/local-ts/system-tray) | Background operation with show/hide and quit actions |\n| [Notifications](/local-ts/notifications) | Native notifications with permission handling |\n| [Database](/local-ts/database) | SQLite with Diesel ORM and automatic migrations |\n| [Theming](/local-ts/theming) | Light, dark, and system theme modes |\n| [Logging](/local-ts/logging) | Multi-target logging to console, webview, and files |\n| [Window State](/local-ts/window-state) | Remember window size and position across restarts |\n| [Autostart](/local-ts/autostart) | Launch at login with user-configurable settings |\n| [Splash Screen](/local-ts/splash-screen) | Elegant loading screen while app initializes |\n\n## Quick Start\n\n### 1. Clone the Repository\n\n```bash\ngit clone https://github.com/zap-studio/local.ts.git my-app\ncd my-app\n```\n\n### 2. Install Dependencies\n\n```bash\npnpm install\n```\n\n### 3. Run the Development Server\n\n```bash\npnpm tauri dev\n```\n\nYour app will open in a native window with hot reload enabled.\n\n## Project Structure\n\n```text\nlocal.ts/\n‚îú‚îÄ‚îÄ src/                    # Frontend React code\n‚îÇ   ‚îú‚îÄ‚îÄ components/         # UI components\n‚îÇ   ‚îú‚îÄ‚îÄ routes/             # TanStack Router pages\n‚îÇ   ‚îú‚îÄ‚îÄ stores/             # Zustand state management\n‚îÇ   ‚îú‚îÄ‚îÄ lib/                # Utilities and Tauri API wrappers\n‚îÇ   ‚îî‚îÄ‚îÄ constants/          # App configuration\n‚îú‚îÄ‚îÄ src-tauri/              # Rust backend\n‚îÇ   ‚îú‚îÄ‚îÄ src/\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ commands/       # Tauri commands (API endpoints)\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ database/       # Diesel ORM models and schema\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ services/       # Business logic and database operations\n‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ plugins/        # Plugin configurations\n‚îÇ   ‚îî‚îÄ‚îÄ migrations/         # Database migrations\n‚îî‚îÄ‚îÄ public/                 # Static assets\n```\n\n## What's Next?\n\nWith all these features built-in, Local.ts gives you everything needed to start building production-ready local-first applications.\n\nExplore the individual feature guides to learn more about each capability, customize them for your needs, and ship your first offline-capable desktop app.\n",
  "local-ts/getting-started.md": "# Getting Started\n\nThis guide walks you through setting up Local.ts and running your first build.\n\n## Prerequisites\n\nBefore you begin, make sure you have the following installed:\n\n- **Node.js** (v18 or later) ‚Äî [nodejs.org](https://nodejs.org/)\n- **Rust** ‚Äî [rust-lang.org](https://www.rust-lang.org/tools/install)\n- **pnpm** (recommended) ‚Äì [pnpm.io](https://www.pnpm.io/)\n- **Turbo** ‚Äî [turborepo.com](https://turborepo.com/)\n\n::: tip\nFor database migrations, optionally install Diesel CLI:\n\n```bash\ncargo install diesel_cli\n```\n:::\n\n## Installation\n\n### 1. Clone the Repository\n\n```bash\ngit clone https://github.com/zap-studio/local.ts.git my-app\ncd my-app\n```\n\n### 2. Install Dependencies\n\n```bash\npnpm install\n```\n\nThis installs npm packages.\n\n### 3. Run in Development Mode\n\n```bash\nturbo tauri -- dev\n```\n\nThis starts the Vite development server with hot reload and opens your app in a native window. Changes to your React code will update instantly.\n\n## Building for Production\n\nCreate a production build for your current platform:\n\n```bash\nturbo tauri -- build\n```\n\nThe output will be in `src-tauri/target/release/bundle/` with platform-specific installers.\n\n## Customizing Your App\n\nAfter cloning, update your app's name, version, and branding. See the [Project Identity](/local-ts/project-identity) guide for a complete walkthrough.\n\n## Available Run Scripts\n\nLocal.ts includes several scripts to streamline your development workflow.\n\n| Command | Description |\n|---------|-------------|\n| `turbo dev` | Start Vite dev server (frontend only) |\n| `turbo tauri -- dev` | Start full app with hot reload |\n| `turbo tauri -- build` | Build for production |\n| `turbo check` | TypeScript type checking |\n| `turbo lint` | Run linter |\n| `turbo format` | Format code |\n| `turbo test` | Run tests |\n| `turbo validate` | Run build, check, lint, and test to validate everything passes |\n\n::: tip\nThe `validate` script is useful before committing or deploying‚Äîit ensures your code builds correctly and passes all quality checks in one command.\n:::\n\n## What's Next?\n\nReady to dive deeper? Explore the guides to learn about specific features like [Settings](/local-ts/settings), [Database](/local-ts/database), and [System Tray](/local-ts/system-tray).\n",
  "local-ts/distribution.md": "# Distribution\n\nOnce your app is ready, you will package and distribute it so users can install and run it. \n\nTauri supports producing platform-native bundles and installers; this document gives a concise overview of the concepts and pointers to the official Tauri documentation for platform-specific details.\n\n## Building for Production\n\nUse the Tauri build command to produce production bundles for one or more targets:\n\n```bash\n# Build all configured bundles\nturbo tauri -- build\n```\n\nBuild artifacts are produced under `src-tauri/target/release/bundle/` and typically include platform-appropriate formats. Configure what gets produced in your `tauri.conf.json` bundle section.\n\n- macOS: `.dmg`, `.app`\n- Windows: `.msi`, `.exe`\n- Linux: `.deb`, `.rpm`, `.AppImage`\n\nA minimal `bundle` configuration may look like:\n\n```json\n{\n  \"bundle\": {\n    \"active\": true,\n    \"targets\": \"all\",\n    \"identifier\": \"com.yourcompany.yourapp\"\n  }\n}\n```\n\nFor full configuration options, see the Tauri distribution configuration docs.\n\n## Code Signing\n\nCode signing is the process of cryptographically signing your app binaries and installers so platforms and users can verify the publisher and integrity of the software.\n\nThe goal is to establish publisher identity, enable notarization on macOS, and reduce warnings (e.g., Windows SmartScreen).\n\n- macOS: typically requires an Apple Developer account and notarization for broad distribution.\n- Windows: uses a code signing certificate from a trusted CA (or platform-specific signing services).\n- Linux: signing is less centralized; some package formats or distribution channels support signatures for verification.\n\nThis guide does not cover step-by-step signing commands or environment configuration.\n\nFor platform-specific signing steps, certificates, and notarization details, follow the [Tauri signing guides](https://v2.tauri.app/distribute/sign/macos/).\n\n## Automatic Updates\n\nAutomatic updates let your app check for, download, and apply new versions without users manually reinstalling.\n\nAn update manifest or endpoint advertises the latest version, the updater checks that endpoint and verifies update integrity (signatures), then downloads and installs updates.\n\nTauri provides an [updater plugin](https://v2.tauri.app/plugin/updater/) and patterns for hosting update metadata and artifacts.\n\n## App Stores\n\nIf you plan to publish to platform app stores, be aware of their extra requirements:\n\n- macOS App Store: App Sandbox, entitlements, and App Store-specific packaging.\n- Microsoft Store: MSIX packaging and Partner Center submission.\n- Linux stores (Flathub, Snap Store, etc.): packaging formats and store submission processes differ.\n\nCheck the [Tauri app stores](https://v2.tauri.app/distribute/) documentation and the target store's guidelines for the precise steps and policies.\n\n## CI/CD\n\nWe provide a GitHub Action workflow that automates the build and release process across all supported platforms. The workflow builds native bundles for macOS (both Apple Silicon and Intel), Windows, and Linux, then creates a draft GitHub release with the artifacts.\n\n### Overview\n\nThe [publish workflow](https://github.com/zap-studio/local.ts/blob/main/.github/workflows/publish.yml) is triggered either manually via `workflow_dispatch` or automatically when pushing to the `release` branch. It uses a matrix strategy to build in parallel across different platforms:\n\n- **macOS** (both `aarch64-apple-darwin` for M1+ and `x86_64-apple-darwin` for Intel)\n- **Ubuntu 22.04** for Linux bundles\n- **Windows** for Windows installers\n\n### Key Features\n\n- **Parallel builds**: All platform targets build simultaneously using GitHub's matrix strategy\n- **Caching**: Both pnpm and Rust dependencies are cached to speed up builds\n- **Draft releases**: Creates a draft GitHub release tagged as `app-v__VERSION__` with all platform artifacts\n- **Platform dependencies**: Automatically installs required system dependencies (e.g., WebKit libraries on Ubuntu)\n\n### Using the Workflow\n\n1. Push to the `release` branch or manually trigger the workflow\n2. The workflow builds all platform bundles\n3. A draft release is created with all artifacts attached\n4. Review the draft release and publish when ready\n\nFor more details on customizing this workflow or setting up your own CI/CD pipeline, see the [Tauri GitHub Pipelines guide](https://tauri.app/distribute/pipelines/github/).\n\n## Learn More\n\nFor full, authoritative, and up-to-date instructions ‚Äî including commands, certificates, keys, and security guidance ‚Äî see the Tauri documentation:\n\n- [Tauri Distribution Overview](https://v2.tauri.app/distribute/)\n- [Tauri Signing Guides](https://v2.tauri.app/distribute/sign/)\n- [Tauri Updater Plugin](https://v2.tauri.app/plugin/updater/)\n- [Tauri GitHub Action](https://github.com/tauri-apps/tauri-action)\n",
  "local-ts/database.md": "# Database\n\nLocal.ts uses [SQLite](https://sqlite.org/index.html) for persistent data storage with [Diesel ORM](https://diesel.rs/) for type-safe queries. All database operations run in Rust and are exposed to your React app via Tauri commands.\n\n## How It Works\n\nThe database system follows a layered architecture:\n\n1. **Models** (`database/models/`) ‚Äî Data structure definitions and type conversions\n2. **Services** (`services/`) ‚Äî Business logic and database operations\n3. **Commands** (`commands/`) ‚Äî Tauri command handlers that call services\n4. **Frontend** ‚Äî React code that invokes Tauri commands\n\n```\nFrontend (React)\n    ‚Üì invoke()\nCommands (Tauri handlers)\n    ‚Üì\nServices (Database operations)\n    ‚Üì\nModels (Data structures) + Diesel ORM\n    ‚Üì\nSQLite Database\n```\n\nWhen your app starts:\n1. The database file is created in the app's data directory if it doesn't exist\n2. Pending migrations are run automatically\n3. A connection pool is initialized for efficient database access\n\n::: info\nA **connection pool** is a set of reusable database connections that helps your app handle multiple queries efficiently.\n\nLocal.ts uses [r2d2](https://docs.rs/r2d2/latest/r2d2/) for pooling, which manages connections so you don't need to open and close them for every request.\n:::\n\n## Database Location\n\nThe SQLite database file is stored in the platform-specific app data directory:\n\n| Platform | Location |\n|----------|----------|\n| macOS | `~/Library/Application Support/{bundleIdentifier}/local.db` |\n| Windows | `C:\\Users\\{User}\\AppData\\Roaming\\{bundleIdentifier}\\local.db` |\n| Linux | `~/.local/share/{bundleIdentifier}/local.db` |\n\n## Creating a New Table\n\nLet's walk through adding a `users` table to your app.\n\n### 1. Generate a Migration\n\n```bash\ncd src-tauri\ndiesel migration generate create_users\n```\n\nThis creates a timestamped directory:\n\n```\nmigrations/\n‚îî‚îÄ‚îÄ 2024-01-01-000000_create_users/\n    ‚îú‚îÄ‚îÄ up.sql\n    ‚îî‚îÄ‚îÄ down.sql\n```\n\n### 2. Write the SQL\n\nIn `up.sql`:\n\n```sql\nCREATE TABLE users (\n    id INTEGER PRIMARY KEY NOT NULL,\n    name TEXT NOT NULL,\n    email TEXT NOT NULL UNIQUE,\n    created_at INTEGER NOT NULL DEFAULT (strftime('%s', 'now'))\n);\n```\n\nIn `down.sql`:\n\n```sql\nDROP TABLE users;\n```\n\n### 3. Run the Migration\n\n```bash\ndiesel migration run\n```\n\nThis:\n- Creates the `users` table in your database\n- Auto-generates the schema in `src-tauri/src/database/schema.rs`\n\n::: warning\nNever edit `schema.rs` manually. It's regenerated automatically when you run migrations.\n:::\n\n### 4. Create the Rust Model\n\nModels define data structures and type conversions. Create `src-tauri/src/database/models/user.rs`:\n\n```rust\nuse diesel::prelude::*;\nuse serde::{Deserialize, Serialize};\nuse crate::database::schema::users;\n\n#[derive(Debug, Clone, Queryable, Selectable, Serialize)]\n#[diesel(table_name = users)]\npub struct User {\n    pub id: i32,\n    pub name: String,\n    pub email: String,\n    pub created_at: i64,\n}\n\n#[derive(Debug, Clone, Insertable, Deserialize)]\n#[diesel(table_name = users)]\npub struct NewUser {\n    pub name: String,\n    pub email: String,\n}\n```\n\nExport it in `src-tauri/src/database/models/mod.rs`:\n\n```rust\npub mod user;\n\npub use user::{User, NewUser};\n```\n\n### 5. Create the Service\n\nServices contain database operations. Create `src-tauri/src/services/user.rs`:\n\n```rust\nuse diesel::prelude::*;\nuse diesel::SqliteConnection;\nuse crate::database::DbError;\nuse crate::database::models::{User, NewUser};\nuse crate::database::schema::users;\n\npub fn list_users(conn: &mut SqliteConnection) -> Result<Vec<User>, DbError> {\n    users::table\n        .load::<User>(conn)\n        .map_err(Into::into)\n}\n\npub fn create_user(\n    conn: &mut SqliteConnection,\n    new_user: NewUser\n) -> Result<User, DbError> {\n    diesel::insert_into(users::table)\n        .values(&new_user)\n        .execute(conn)?;\n\n    users::table\n        .order(users::id.desc())\n        .first(conn)\n        .map_err(Into::into)\n}\n\npub fn get_user(\n    conn: &mut SqliteConnection,\n    user_id: i32\n) -> Result<Option<User>, DbError> {\n    users::table\n        .find(user_id)\n        .first(conn)\n        .optional()\n        .map_err(Into::into)\n}\n```\n\nExport it in `src-tauri/src/services/mod.rs`:\n\n```rust\npub mod user;\n```\n\n### 6. Create Tauri Commands\n\nCommands are thin wrappers that call services. Create `src-tauri/src/commands/user.rs`:\n\n```rust\nuse tauri::State;\nuse crate::database::{DbPool, DbError};\nuse crate::database::models::NewUser;\nuse crate::services::user;\n\n#[tauri::command]\npub fn list_users(pool: State<DbPool>) -> Result<Vec<user::User>, DbError> {\n    let mut conn = pool.get()?;\n    user::list_users(&mut conn)\n}\n\n#[tauri::command]\npub fn create_user(\n    pool: State<DbPool>,\n    new_user: NewUser\n) -> Result<user::User, DbError> {\n    let mut conn = pool.get()?;\n    user::create_user(&mut conn, new_user)\n}\n\n#[tauri::command]\npub fn get_user(\n    pool: State<DbPool>,\n    user_id: i32\n) -> Result<Option<user::User>, DbError> {\n    let mut conn = pool.get()?;\n    user::get_user(&mut conn, user_id)\n}\n```\n\n### 7. Register the Commands\n\nIn `src-tauri/src/lib.rs`:\n\n```rust\n.invoke_handler(tauri::generate_handler![\n    // ... existing commands\n    commands::user::list_users,\n    commands::user::create_user,\n    commands::user::get_user,\n])\n```\n\n::: warning\nIf you don't register your commands with Tauri using `invoke_handler`, your frontend won't be able to call them. Always ensure new commands are added here.\n:::\n\n### 8. Call from React\n\n```typescript\nimport { invoke } from \"@tauri-apps/api/core\";\n\ninterface User {\n  id: number;\n  name: string;\n  email: string;\n  createdAt: number;\n}\n\n// List all users\nconst users = await invoke<User[]>(\"list_users\");\n\n// Create a new user\nconst newUser = await invoke<User>(\"create_user\", {\n  user: { name: \"Alice\", email: \"alice@example.com\" }\n});\n\n// Get a specific user\nconst user = await invoke<User | null>(\"get_user\", { userId: 1 });\n```\n\n## Common Queries\n\nFor more details and advanced query examples, check the [Diesel ORM documentation](https://diesel.rs/guides/).\n\n## Modifying Existing Tables\n\nTo add a column to an existing table:\n\n```bash\ndiesel migration generate add_avatar_to_users\n```\n\nIn `up.sql`:\n\n```sql\nALTER TABLE users ADD COLUMN avatar_url TEXT;\n```\n\nIn `down.sql`:\n\n```sql\nALTER TABLE users DROP COLUMN avatar_url;\n```\n\nRun the migration and update your Rust model to include the new field.\n\n## Connection Pool\n\nThe connection pool is initialized at startup in `src-tauri/src/database/mod.rs`:\n\n```rust\nlet pool = r2d2::Pool::builder()\n    .max_size(10)\n    .build(manager)?;\n```\n\nYou can adjust `max_size` based on your app's concurrency needs. For most desktop apps, 10 connections is more than sufficient.\n",
  "local-ts/code-quality.md": "# Code Quality\n\nLocal.ts comes with a complete code quality setup using modern, fast tooling. This guide covers linting, formatting, testing, and the monorepo task runner.\n\n## Ultracite\n\n[Ultracite](https://www.ultracite.ai/) is a zero-configuration linter and formatter preset designed to enforce high code quality standards.\n\nIt can unify linting and formatting using different engines, such as Biome, Prettier with ESLint, or the oxlint and oxfmt tools.\n\nIn this project, we use the oxlint + oxfmt combo for fast, modern linting and formatting.\n\n### Why Ultracite?\n\n- **Fast** ‚Äî Rust-based engine runs in milliseconds\n- **Zero-config** ‚Äî Sensible defaults out of the box\n- **Unified** ‚Äî Linting and formatting in one tool\n- **Auto-fix** ‚Äî Most issues are automatically fixable\n\n### Commands\n\n```bash\n# Format and fix all issues\npnpm dlx ultracite fix\n\n# Check for issues without fixing\npnpm dlx ultracite check\n\n# Diagnose setup issues\npnpm dlx ultracite doctor\n```\n\nOr using Turborepo:\n\n```bash\nturbo format   # Fix issues\nturbo lint     # Check issues\n```\n\n### Configuration\n\nUltracite works with oxlint under the hood. The configuration is in `.oxlintrc.json`:\n\n```json\n{\n  \"$schema\": \"./node_modules/oxlint/configuration_schema.json\",\n  \"extends\": [\"ultracite/oxlint/core\", \"ultracite/oxlint/react\"]\n}\n```\n\nThe presets include rules for:\n- TypeScript best practices\n- React hooks and accessibility\n- Modern JavaScript patterns\n- Security and performance\n\n### Pre-commit Hooks\n\nLocal.ts uses Lefthook to run Ultracite on staged files before each commit:\n\n```yaml\n# lefthook.yml\npre-commit:\n  jobs:\n    - run: pnpm dlx ultracite fix\n      glob:\n        - \"*.js\"\n        - \"*.jsx\"\n        - \"*.ts\"\n        - \"*.tsx\"\n        - \"*.json\"\n        - \"*.jsonc\"\n        - \"*.css\"\n      stage_fixed: true\n```\n\nThis ensures all committed code passes linting and formatting checks.\n\n## Testing with Vitest\n\nLocal.ts uses [Vitest](https://vitest.dev/) for testing. Vitest is a fast, Vite-native test runner with a Jest-compatible API.\n\n### Running Tests\n\n```bash\n# Run tests once\nturbo test\n\n# Watch mode for development\nturbo test:watch\n\n# Generate coverage report\nturbo test:coverage\n\n# Open the UI test runner\nturbo test:ui\n```\n\n### Configuration\n\nTesting is configured in `vite.config.ts`:\n\n```typescript\nexport default defineConfig({\n  // ... other config\n  test: {\n    coverage: {\n      provider: \"v8\",\n      reporter: [\"text\", \"html\"],\n    },\n  },\n});\n```\n\n### Writing Tests\n\nCreate test files with the `.test.ts` or `.test.tsx` extension:\n\n```typescript\nimport { describe, it, expect } from \"vitest\";\n\ndescribe(\"myFunction\", () => {\n  it(\"should return the correct value\", () => {\n    expect(myFunction(2)).toBe(4);\n  });\n});\n```\n\n### Coverage Reports\n\nCoverage reports are generated in the `coverage/` directory:\n\n- `coverage/index.html` ‚Äî Interactive HTML report\n- Terminal output shows summary\n\n## Turborepo\n\n[Turborepo](https://turborepo.com/) orchestrates tasks across the monorepo, handling both the frontend (Vite) and backend (Tauri/Rust) with unified commands and intelligent caching.\n\n### Monorepo Structure\n\nLocal.ts is structured as a pnpm workspace with two packages:\n\n```yaml\n# pnpm-workspace.yaml\npackages:\n  - .           # Frontend (React/Vite)\n  - ./src-tauri # Backend (Rust/Tauri)\n```\n\nThis allows Turborepo to run tasks across both packages with a single command.\n\n### Task Configuration\n\nTasks are defined in `turbo.json`:\n\n```json\n{\n  \"$schema\": \"https://turborepo.com/schema.json\",\n  \"tasks\": {\n    \"build\": {\n      \"dependsOn\": [\"^build\"],\n      \"outputs\": [\n        \"dist/**\",\n        \"src-tauri/target/release/**\",\n        \"src-tauri/target/debug/**\"\n      ]\n    },\n    \"check\": {\n      \"dependsOn\": [\"^check\"]\n    },\n    \"dev\": {\n      \"persistent\": true,\n      \"cache\": false\n    },\n    \"lint\": {\n      \"dependsOn\": [\"^lint\"]\n    },\n    \"test\": {\n      \"dependsOn\": [\"^build\"]\n    },\n    \"validate\": {\n      \"dependsOn\": [\"build\", \"check\", \"lint\", \"test\"]\n    }\n  }\n}\n```\n\n### Key Concepts\n\n| Concept | Description |\n|---------|-------------|\n| `dependsOn` | Run dependencies first (e.g., `^build` runs build in all deps) |\n| `outputs` | Files to cache for faster subsequent runs |\n| `persistent` | Keep running (for dev servers) |\n| `cache` | Whether to cache task outputs |\n\n### Caching\n\nTurborepo caches task outputs based on file inputs. When you run a task:\n\n1. Turborepo hashes relevant source files\n2. If the hash matches a previous run, it replays cached output\n3. If not, it runs the task and caches the result\n\nThis dramatically speeds up CI pipelines and repeated local builds.\n\n### Available Commands\n\n| Command | Description |\n|---------|-------------|\n| `turbo dev` | Start Vite dev server |\n| `turbo tauri -- dev` | Start full Tauri app with hot reload |\n| `turbo tauri -- build` | Build production app |\n| `turbo build` | Build frontend |\n| `turbo check` | TypeScript type checking |\n| `turbo lint` | Run Ultracite linter |\n| `turbo format` | Format code with Ultracite |\n| `turbo test` | Run Vitest tests |\n| `turbo test:coverage` | Generate coverage report |\n| `turbo validate` | Run all checks (build, check, lint, test) |\n\n### The Validate Command\n\nThe `validate` task runs all quality checks in the correct order:\n\n```json\n{\n  \"validate\": {\n    \"dependsOn\": [\"build\", \"check\", \"lint\", \"test\"]\n  }\n}\n```\n\nUse it before committing or in CI:\n\n```bash\nturbo validate\n```\n\nThis ensures your code:\n- Builds successfully\n- Passes TypeScript checks\n- Passes linting rules\n- Passes all tests\n\n## Cargo\n\nLocal.ts includes a Rust backend in `src-tauri/` with comprehensive tooling for code quality.\n\nThe Rust toolchain provides native tools for formatting, linting, type checking, testing, and coverage.\n\n### Available Cargo Commands\n\n| Command | Description |\n|---------|-------------|\n| `cargo fmt` | Format Rust code with rustfmt |\n| `cargo clippy` | Lint Rust code with Clippy |\n| `cargo check` | Type check without building |\n| `cargo test` | Run Rust unit and integration tests |\n| `cargo tarpaulin` | Generate code coverage reports |\n\n### Turborepo Integration\n\nThe `src-tauri/` directory includes a `package.json` that bridges Cargo commands to the Turborepo workflow. This allows unified commands across both TypeScript and Rust codebases.\n\nHere is a simplified example:\n\n```json\n{\n  \"scripts\": {\n    \"format\": \"cargo fmt\",\n    \"lint\": \"cargo clippy\",\n    \"check\": \"cargo check\",\n    \"test\": \"cargo test\"\n  }\n}\n```\n\nNow you can run Cargo commands through Turborepo alongside your TypeScript tasks:\n\n```bash\n# Format both TypeScript and Rust code\nturbo format\n\n# Lint both codebases\nturbo lint\n\n# Type check TypeScript and Rust\nturbo check\n\n# Run tests for both frontend and backend\nturbo test\n```\n\n### Cargo-specific Workflows\n\nFor Rust-specific tasks, navigate to `src-tauri/` and use Cargo directly:\n\n```bash\ncd src-tauri\n\n# Watch tests during development\ncargo watch -x test\n\n# Run tests with output\ncargo test -- --nocapture\n\n# Generate coverage report\ncargo tarpaulin --out Html\n\n# Fix clippy warnings automatically\ncargo clippy --fix\n```\n\n### Tarpaulin Coverage\n\n[Cargo Tarpaulin](https://github.com/xd009642/tarpaulin) generates code coverage for Rust tests:\n\n```bash\n# Install tarpaulin\ncargo install cargo-tarpaulin\n\n# Generate HTML coverage report\ncargo tarpaulin --out Html\n\n# View in browser\nopen tarpaulin-report.html\n```\n\nCoverage reports help identify untested code paths in your Rust backend.\n\n## CI Integration\n\nLocal.ts includes GitHub Actions workflows that run on every pull request to ensure code quality across the monorepo.\n\n### Existing Workflows\n\n| Workflow | File | Description |\n|----------|------|-------------|\n| **Check** | [check.yml](https://github.com/zap-studio/local.ts/blob/main/.github/workflows/check.yml) | Type checks TypeScript and Rust code |\n| **Lint** | [lint.yml](https://github.com/zap-studio/local.ts/blob/main/.github/workflows/lint.yml) | Runs oxlint linter on the monorepo |\n| **Test** | [test.yml](https://github.com/zap-studio/local.ts/blob/main/.github/workflows/test.yml) | Executes all test suites |\n| **Build** | [build.yml](https://github.com/zap-studio/local.ts/blob/main/.github/workflows/build.yml) | Builds the entire monorepo |\n\n### Workflow Triggers\n\nAll workflows:\n- Run on pull requests\n- Execute in parallel for faster feedback\n- Use pnpm for dependency management\n\n### Leveraging Turborepo in CI\n\nTurborepo caches build artifacts between runs, significantly reducing CI times after the first build:\n\n```yaml\n# Your CI pipeline benefits from Turborepo's cache\n- name: Install dependencies\n  run: pnpm install --frozen-lockfile\n\n- name: Validate\n  run: pnpm turbo run validate\n```\n\n### Remote Caching\n\nFor team environments, enable [Turborepo Remote Caching](https://turborepo.com/repo/docs/core-concepts/remote-caching) to share cache across machines:\n\n```bash\nturbo login\nturbo link\n```\n\nThis allows team members and CI runners to benefit from each other's cached builds, dramatically speeding up workflows.\n",
  "local-ts/autostart.md": "# Autostart\n\nLocal.ts can launch automatically when users log into their computer using the [Tauri autostart plugin](https://v2.tauri.app/plugin/autostart/).\n\nThis is useful for apps that should always be running, like status monitors, chat clients, or sync tools.\n\n## How It Works\n\nThe autostart feature uses platform-specific mechanisms:\n\n| Platform | Method |\n|----------|--------|\n| macOS | LaunchAgent in `~/Library/LaunchAgents/` |\n| Windows | Registry entry in `HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Run` |\n| Linux | Desktop entry in `~/.config/autostart/` |\n\nThe Tauri autostart plugin handles all platform differences automatically.\n\n## Enabling Autostart\n\nFrom your React code:\n\n```typescript\nimport { enable, disable, isEnabled } from \"@tauri-apps/plugin-autostart\";\n\n// Enable autostart\nawait enable();\n\n// Disable autostart\nawait disable();\n\n// Check if enabled\nconst enabled = await isEnabled();\n```\n\n## Settings Integration\n\nLocal.ts includes a \"Launch at Login\" toggle in Settings. The simplified implementation is the following:\n\n```typescript\nconst handleAutostartChange = async (enabled: boolean) => {\n  if (enabled) {\n    await enable();\n  } else {\n    await disable();\n  }\n  await updateSettings({ launchAtLogin: enabled });\n};\n```\n\n## Removing Autostart\n\nIf you don't need autostart functionality:\n\n1. **Remove the plugin** from `src-tauri/src/lib.rs`:\n\n   ```diff\n   - app.handle().plugin(tauri_plugin_autostart::init(\n   -     tauri_plugin_autostart::MacosLauncher::LaunchAgent,\n   -     None,\n   - ))?;\n   ```\n\n2. **Remove the dependency** from `src-tauri/Cargo.toml`:\n\n   ```diff\n   - [target.'cfg(any(target_os = \"macos\", target_os = \"windows\", target_os = \"linux\"))'.dependencies]\n   - tauri-plugin-autostart = \"2\"\n   ```\n\n3. **Remove permissions** from `src-tauri/capabilities/default.json`:\n\n   ```diff\n   - \"autostart:allow-enable\",\n   - \"autostart:allow-disable\",\n   - \"autostart:allow-is-enabled\"\n   ```\n\n4. **Remove the npm package**:\n\n   ```bash\n   pnpm remove @tauri-apps/plugin-autostart\n   ```\n\n5. **Remove the setting** from the Settings page and database models.\n\n::: tip\nCheck whether other dependencies exist inside the `[target.'cfg(any(...)'.dependencies]` section.\n\nIf `tauri-plugin-autostart` is the only entry, remove the entire target-specific `[target.'cfg(...)'.dependencies]` section; otherwise delete only the `tauri-plugin-autostart = \"2\"` line from that section.\n:::\n",
  "local-ts/app-icons.md": "# App Icons\n\nSetting up proper icons ensures your application looks professional across all platforms and contexts.\n\n## Desktop Icons\n\nDesktop icons are used for the application window, taskbar, and installers on Windows, macOS, and Linux.\n\n### Generate Icons\n\nUse the [Tauri Icon Generator](https://tauri.app/develop/icons/) to create icons for all platforms from a single source image:\n\n1. **Prepare your source image**\n   - Format: PNG\n   - Size: 1024x1024 pixels minimum\n   - Background: Transparent (recommended)\n\n2. **Generate icons**\n   ```bash\n   turbo tauri -- icon path/to/your-icon.png\n   ```\n\n3. **Output location**\n   The generated icons will be placed in `src-tauri/icons/` with these files:\n   - `32x32.png`, `128x128.png`, `128x128@2x.png` ‚Äî Windows\n   - `icon.icns` ‚Äî macOS\n   - `icon.ico` ‚Äî Windows\n   - `icon.png` ‚Äî Linux\n\n::: tip\nThe icon generator automatically creates all necessary sizes and formats. You only need to provide one high-quality source image.\n:::\n\n### Manual Icon Placement\n\nIf you already have platform-specific icons, place them directly in `src-tauri/icons/`:\n\n```\nsrc-tauri/\n‚îî‚îÄ‚îÄ icons/\n    ‚îú‚îÄ‚îÄ 32x32.png\n    ‚îú‚îÄ‚îÄ 128x128.png\n    ‚îú‚îÄ‚îÄ 128x128@2x.png\n    ‚îú‚îÄ‚îÄ icon.icns      (macOS)\n    ‚îú‚îÄ‚îÄ icon.ico       (Windows)\n    ‚îî‚îÄ‚îÄ icon.png       (Linux, 512x512)\n```\n\n## Updating Icons\n\nAfter changing icons:\n\n1. **Clear cache** (if icons don't update immediately):\n   ```bash\n   rm -rf src-tauri/target\n   ```\n\n2. **Rebuild the app**:\n   ```bash\n   turbo tauri -- build\n   ```\n\n## Best Practices\n\n1. **Use high-resolution source images** ‚Äî Start with at least 1024x1024px\n2. **Keep it simple** ‚Äî Icons should be recognizable at small sizes (16x16)\n3. **Use transparency** ‚Äî PNG with transparent backgrounds look better\n4. **Test on all platforms** ‚Äî Verify icons appear correctly on Windows, macOS, and Linux\n5. **Consistent branding** ‚Äî Use the same visual identity across desktop and web icons\n\n## Troubleshooting\n\n### Icons not showing in built app\n\nMake sure icon paths in `src-tauri/tauri.conf.json` are correct:\n\n```json\n{\n  \"tauri\": {\n    \"bundle\": {\n      \"icon\": [\n        \"icons/32x32.png\",\n        \"icons/128x128.png\",\n        \"icons/128x128@2x.png\",\n        \"icons/icon.icns\",\n        \"icons/icon.ico\"\n      ]\n    }\n  }\n}\n```\n"
} as const;
export type DocPath = keyof typeof allDocs;